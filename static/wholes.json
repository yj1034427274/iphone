{"success":true,"data":[{"id":"5d5bed6ed53e9171e98a975b","author_id":"516f989a6d38277306ae8c1b","tab":"share","content":"<div class=\"markdown-text\"><p>这是一次硬核的地下铁沙龙，\n我们深入 Node.js 运行时底层，\n来讨论如何进行运行时的优化和诊断，\n让它可以在 Serverless，IoT 等等场景释放更大的价值。</p>\n<p>五位重量级的嘉宾，\n有 Node.js 技术委员会（TSC）成员，\n有来自浏览器厂商的骨灰级技术专家，\n还有阿里、Rokid 的大牛。</p>\n<p>欢迎你和我们一起，进入深海。</p>\n<p><strong>Agenda</strong>\n<img src=\"https://img.alicdn.com/tfs/TB10BqFdLb2gK0jSZK9XXaEgFXa-1408-2040.png\" alt=\"Agenda\"></p>\n<p>时 间：2019.09.08 下午 2 点\n地 点：杭州·玉泉饭店（具体地址详见邀约）</p>\n<p>报 名 链 接: <a href=\"https://survey.alibaba.com/apps/zhiliao/QlwUc77lF\">https://survey.alibaba.com/apps/zhiliao/QlwUc77lF</a>\n活 动 主 页: <a href=\"https://fed.taobao.org/subway/\">https://fed.taobao.org/subway/</a></p>\n<p><strong>已经报名的可以查看报名时的填写的邮箱，了解最新情况。</strong></p>\n<p><strong>9.19 更新</strong>\nPPT 下载地址：<a href=\"https://github.com/midwayjs/subway-station/tree/master/No.9.HangZhou.Let%E2%80%99s%20Go%20Deep!\">Github</a>\n视频地址: <a href=\"http://list.youku.com/albumlist/show/id_52277135.html\">Youku</a></p>\n</div>","title":"Node 地下铁第九期「杭州站」线下沙龙邀约 - Let's Go Deep","last_reply_at":"2019-09-23T13:23:48.398Z","good":false,"top":true,"reply_count":31,"visit_count":27298,"create_at":"2019-08-20T12:54:06.836Z","author":{"loginname":"mariodu","avatar_url":"//gravatar.com/avatar/1cb272a2b4347c9a15b502ce7e4802ba?size=48"}},{"id":"5d83017a95464514f7ed816c","author_id":"5d82f86c53c75a4136b4ba32","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fn9bDYf7IImtrvbUiHzvBHuGyusX\" alt=\"flyer copy.png\"></p>\n<p>JavaScript 中国开发者大会是一个以技术开发者为中心的非盈利国际性技术大会，本届大会的讲师阵容强大，来自Nike、Microsoft、Google、Tencent、Alibaba等知名科技公司；演讲内容丰富，从前端到后端、从语言特性到工具应用等多个角度和层面；两场免费工作坊，手把手指导你从零完成一件事。亲临大会现场，与讲师及各类大小公司近距离沟通，还有招聘环节和招聘墙，无论你是想要推销自己还是为公司招聘，都有机会。现场还将进行抽奖、竞赛、提问等互动环节，得益于Nike、Microsoft 等公司的支持，丰富的奖品等你来拿！</p>\n<p>购票链接：<a href=\"https://www.bagevent.com/event/5261869\">https://www.bagevent.com/event/5261869</a>\n【85折优惠码：“91vlxt5n”】【只有20张，先到先到】</p>\n<p>更多信息，请移步<a href=\"https://2019.jsconfchina.com/cn/\">官网</a>，如有任何问题，欢迎咨询 <a href=\"mailto:info@jsconfchina.com\">info@jsconfchina.com</a>.</p>\n<p><img src=\"//static.cnodejs.org/Fm-qQRgYDzgN8w5e2A2NP11n3aKN\" alt=\"WechatIMG11.png\"></p>\n</div>","title":"2019 中国 JavaScript 开发者大会，10月登陆上海！【赠送折扣码】","last_reply_at":"2019-09-22T09:07:27.494Z","good":false,"top":true,"reply_count":1,"visit_count":4955,"create_at":"2019-09-19T04:18:02.573Z","author":{"loginname":"zhenghuii","avatar_url":"https://avatars3.githubusercontent.com/u/15156317?v=4&s=120"}},{"id":"5cbfd9aca86ae80ce64b3175","author_id":"4f447c2f0a8abae26e01b27d","tab":"share","content":"<div class=\"markdown-text\"><h2>前言</h2>\n<p>时隔一年，Node.js 12 如约而至，正式发布第一个 <a href=\"https://github.com/nodejs/Release\">Current</a> 版本。</p>\n<p>该版本带来了诸如：</p>\n<ul>\n<li>V8 更新带来好多不错的特性。</li>\n<li>HTTP 解析速度提升。</li>\n<li>启动速度大幅提升。</li>\n<li>更好的诊断报告和堆分析工具。</li>\n<li>ESM 模块更新。</li>\n</ul>\n<p>原文地址：<a href=\"https://medium.com/@nodejs/introducing-node-js-12-76c41a1b3f3f\">https://medium.com/@nodejs/introducing-node-js-12-76c41a1b3f3f</a>\n语雀地址：<a href=\"https://www.yuque.com/egg/nodejs/nodejs-12\">https://www.yuque.com/egg/nodejs/nodejs-12</a></p>\n<h2>LTS vs Current</h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/84182/1556074709431-35af45b8-ec7a-4a81-83d8-155eb519f04a.png#align=left&amp;display=inline&amp;height=389&amp;name=image.png&amp;originHeight=500&amp;originWidth=960&amp;size=58313&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>如果你不了解 Node.js 的  Long Term Support 发布策略的话，一定要看看 <a href=\"https://github.com/nodejs/Release\">https://github.com/nodejs/Release</a> 。</p>\n<p>就目前而言，Node.js 6.x 和 8.x 将在 2019 年末结束 LTS 的支持，大家尽快升级到 10.x 吧。</p>\n<h2>快速体验</h2>\n<pre class=\"prettyprint language-bash\"><code>$ nvs add node&#x2F;12\n$ nvs use 12\n$ node -v\nv12.0.0\n</code></pre><p>具体参考这篇文章：<a href=\"https://zhuanlan.zhihu.com/p/63403762\">科普文：使用 nvs 管理本地 Node.js 版本</a></p>\n<h2>V8 更新到 7.4</h2>\n<blockquote>\n<p>大部分情况下，我们不用去考虑性能问题，坐等 V8 版本更新就好了。（大雾）</p>\n</blockquote>\n<p>本次版本更新，也带来了好几个不错的特性：</p>\n<ul>\n<li><a href=\"https://v8.dev/blog/v8-release-72#async-stack-traces\">异步堆栈跟踪</a></li>\n<li><a href=\"https://v8.dev/blog/v8-release-74#faster-calls-with-arguments-mismatch\">参数调用不匹配时的调用速度优化</a></li>\n<li><a href=\"https://v8.dev/blog/v8-release-73#faster-await\">更快的 await</a></li>\n<li><a href=\"https://v8.dev/blog/v8-release-72#javascript-parsing\">更快的 JavaScript 解析速度</a></li>\n</ul>\n<p><strong>同时，跑了下我们 Egg 的一些内部测试，发现序列化有 10~20% 的性能提升，恐怖如斯！</strong></p>\n<p>另，奇丑无比的 <a href=\"https://github.com/tc39/proposal-class-fields\">Private Class Fields</a> 也能用了：</p>\n<pre class=\"prettyprint language-javascript\"><code>class IncreasingCounter {\n  #count = 0;\n  \n  get value() {\n    console.log(&#x27;Getting the current value!&#x27;);\n    return this.#count;\n  }\n  increment() {\n    this.#count++;\n  }\n}\n</code></pre><h2>HTTP 解析速度提升</h2>\n<p>默认的 HTTP 解析器切换为 <a href=\"https://github.com/nodejs/llhttp\">llhttp</a> ，性能提升恐怖如斯：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/84182/1556072499637-686bb0e3-c75c-424c-851f-ad88aff183a2.png#align=left&amp;display=inline&amp;height=231&amp;name=image.png&amp;originHeight=404&amp;originWidth=1302&amp;size=88775&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<blockquote>\n<p>点评：恐怖如斯。</p>\n</blockquote>\n<h2>启动速度提升</h2>\n<p>通过 <a href=\"https://v8.dev/blog/code-caching\">v8 code cache</a> 的支持，<a href=\"https://github.com/nodejs/node/pull/27161\">在构建时提前为内置库生成代码缓存</a>，从而提升 30% 的启动耗时。\n同时，通过<a href=\"https://github.com/nodejs/node/pull/24950\">重用主进程缓存</a>，Workers Threads 的启动速度提升了 60% 。</p>\n<blockquote>\n<p>点评：恐怖如斯。</p>\n</blockquote>\n<h2>Workers Threads</h2>\n<p>在 10.x 已经引入的 <a href=\"https://nodejs.org/api/worker_threads.html\">Workers Threads</a> 特性，在 12.x 里面默认启用，无需使用 <code>--experimental-worker</code> 开启。同时基于上一条的介绍，启动的速度也得到大幅提升。</p>\n<p>相关介绍：<a href=\"https://medium.com/@Trott/using-worker-threads-in-node-js-80494136dbb6\">https://medium.com/@Trott/using-worker-threads-in-node-js-80494136dbb6</a></p>\n<h2>诊断报告</h2>\n<p>提供了新的实验性功能『诊断报告』，一个非常有用的特性。\n可用于帮助分析诸如：崩溃，性能问题，内存泄漏，高 CPU 占用等等问题。详见 <a href=\"https://medium.com/the-node-js-collection/easily-identify-problems-in-node-js-applications-with-diagnostic-report-dc82370d8029\">这篇文章</a>。</p>\n<blockquote>\n<p>点评：这也是 <a href=\"https://www.aliyun.com/product/nodejs\">AliNode</a> 之前的一个卖点之一。</p>\n</blockquote>\n<h2>Heap Dump</h2>\n<p>以前我们分析问题的时候，需要手动安装对应的类库或者使用 AliNode。</p>\n<p>在 12.x 里面内置了该功能，详见：</p>\n<ul>\n<li><a href=\"https://github.com/nodejs/node/pull/27133\">https://github.com/nodejs/node/pull/27133</a></li>\n<li><a href=\"https://github.com/nodejs/node/pull/26501\">https://github.com/nodejs/node/pull/26501</a></li>\n</ul>\n<blockquote>\n<p>点评：又一个 <a href=\"https://www.aliyun.com/product/nodejs\">AliNode</a> 的功能被内置了。但其实影响不大，AliNode 的核心在于分析平台，这块的采集能力，本来他们就打算开源回馈出去的。</p>\n</blockquote>\n<p>同时，由于上述提到的 V8 升级，现在可以按照可用内存动态调整堆大小了。</p>\n<h2>ESM 模块方案更新</h2>\n<p>ES6 模块仍然还在实验阶段，不过有了新的方式，具体参见<a href=\"https://medium.com/@nodejs/announcing-a-new-experimental-modules-1be8d2d6c2ff\">这篇文章</a>。</p>\n<blockquote>\n<p>点评：让子弹再飞一会，该特性真的不是痛点，不急。</p>\n</blockquote>\n<h2>其他更新</h2>\n<ul>\n<li>更好的原生模块支持，<a href=\"https://nodejs.org/api/n-api.html#n_api_n_api\">N-API</a> 升级为版本 4，并 backport 到 Node.js 8.x 和 10.x。详细参见<a href=\"https://medium.com/the-node-js-collection/new-features-bring-native-add-ons-close-to-being-on-par-with-js-modules-cd4f9b8e4b4\">这篇文章</a>。</li>\n<li>TLS 升级为 1.3， <a href=\"https://developer.ibm.com/blogs/openssl-111-has-landed-in-nodejs-master-and-why-its-important-for-nodejs-lts-releases/\">增强安全功能</a>。</li>\n<li>随着 C++ 编译器的更新，现在要求 <code>GCC 6</code> 和 <code>glibc 2.17</code> ，对应的操作系统 Win7 和 macOS 10，详细参见<a href=\"https://github.com/nodejs/node/blob/v12.x/BUILDING.md#platform-list\">这篇文章</a>。</li>\n</ul>\n<p>不过目前 node-gyp 的一些原生模块会编译失败：</p>\n<pre class=\"prettyprint language-bash\"><code>nunjucks@3.2.0 › chokidar@2.1.5 › fsevents@^1.2.7 optional error: Error: Run &quot;sh -c node install&quot; error, exit code 1\n    at ChildProcess.&lt;anonymous&gt; (&#x2F;Users&#x2F;tz&#x2F;.npm-global&#x2F;lib&#x2F;node_modules&#x2F;tnpm&#x2F;node_modules&#x2F;_runscript@1.3.0@runscript&#x2F;index.js:74:21)\n    at ChildProcess.emit (events.js:196:13)\n    at maybeClose (internal&#x2F;child_process.js:1000:16)\n    at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:267:5)\n</code></pre></div>","title":"Node 12 值得关注的新特性","last_reply_at":"2019-09-07T09:27:38.616Z","good":false,"top":true,"reply_count":62,"visit_count":131095,"create_at":"2019-04-24T03:36:12.582Z","author":{"loginname":"atian25","avatar_url":"https://avatars2.githubusercontent.com/u/227713?v=4&s=120"}},{"id":"5d8c98aee86cfb0d2a645ff7","author_id":"57bd18546b04813133ba9116","tab":"ask","content":"<div class=\"markdown-text\"><p>以往的Nodejs项目里我习惯使用Mongoose来连接Mongodb。单节点的情况下用起来很顺手，但是对于副本集的支持总觉得不是那么完美。尤其是副本集发送主节点切换的情况，mongoose有时候甚至主动重连都会失败。不知道大神们有没有遇到和我类似的问题，求各路神仙指点啊！不胜感激！</p>\n</div>","title":"如何添加Mongodb副本集支持，并且支持自动切换master节点连接？","last_reply_at":"2019-09-26T10:53:34.129Z","good":false,"top":false,"reply_count":0,"visit_count":59,"create_at":"2019-09-26T10:53:34.129Z","author":{"loginname":"jonathang4","avatar_url":"https://avatars0.githubusercontent.com/u/11583266?v=4&s=120"}},{"id":"5b7ac9c7c52ad1482eb940bf","author_id":"5b52cbf1fb9e84ec69cc1ca2","tab":"ask","content":"<div class=\"markdown-text\"><p>Egg.js现在用的人多吗？那些公司在用有知道的吗？</p>\n<p>同上，老铁们出来吧。</p>\n</div>","title":"Egg.js现在用的人多吗？那些公司在用有知道的吗？","last_reply_at":"2019-09-26T09:26:51.734Z","good":false,"top":false,"reply_count":138,"visit_count":21827,"create_at":"2018-08-20T14:01:43.981Z","author":{"loginname":"nodeper","avatar_url":"https://avatars2.githubusercontent.com/u/41500847?v=4&s=120"}},{"id":"5d8973eb5cbcc579bb9ea593","author_id":"5cede24d4036f24194cf7669","tab":"ask","content":"<div class=\"markdown-text\"><p>老哥们好，其实起这个标题不是很准确。但是我也不确定我这个问题起什么标题。是这样的，小弟目前的项目用到了通讯，项目是一个微信公众号，主要功能是提供学校学生公寓充值水电费。然后差不多每个操作都需要到客户端获取数据在返回主程序端。每个学校就是一个客户端，客户端放在学校本地。然后项目的session是放在redius。目前遇到一个内存泄露的问题。因为请求的时候需要到客户端获取数据，所以req,和res对象会存到一个数组，等获取到数据后传到主程序后在冲数组中获取req，和res对象。那么就会有问题，这个数组会越来越大而且几乎永远不会被释放。现在高峰期学生使用多的时候只能通过定时重启解决。不知道我这个描述老哥们是否看懂。如果有老哥看懂并且有什么办法的话希望能帮帮小弟。\n<img src=\"//static.cnodejs.org/FnGptcDXllnOh2Ig7G4TXGPzNr-0\" alt=\"12.png\">\n这里传到客户端之前把req，res存起来key是当前的时间，\n<img src=\"//static.cnodejs.org/FkTSU4hpZUCA4V4U6QPu2EPLWh7n\" alt=\"21.jpg\">\n然后这个函数是客户端把数据传过来后执行数据操作的函数，这里根据刚刚的时间从数组中获取req,res对象。这样才能处理完这个请求，返回给前端数据或者是成功失败的状态。</p>\n</div>","title":"node 通讯问题。","last_reply_at":"2019-09-26T08:40:03.587Z","good":false,"top":false,"reply_count":10,"visit_count":700,"create_at":"2019-09-24T01:39:55.470Z","author":{"loginname":"SKandAV","avatar_url":"https://avatars0.githubusercontent.com/u/26410064?v=4&s=120"}},{"id":"5d8c6fede86cfb0d2a645e8e","author_id":"5bb04bceede204052db802d7","tab":"ask","content":"<div class=\"markdown-text\"><p>请问，一个合格的高级前端开发需要具备哪些前端技能？前端架构师需要具备哪些技能？</p>\n</div>","title":"高级前端开发工程师","last_reply_at":"2019-09-26T07:59:41.938Z","good":false,"top":false,"reply_count":0,"visit_count":201,"create_at":"2019-09-26T07:59:41.938Z","author":{"loginname":"mschange","avatar_url":"https://avatars1.githubusercontent.com/u/36876310?v=4&s=120"}},{"id":"5d883b6b95464514f7ed925a","author_id":"59001c9bbbaf2f3f569be2b4","tab":"ask","content":"<div class=\"markdown-text\"><p>webpack能不能像编译前端（vue等）项目一样编译后端koa项目？有没有相应的教程？</p>\n</div>","title":"webpack如何向前端一样编译koa后端项目","last_reply_at":"2019-09-26T06:56:31.165Z","good":false,"top":false,"reply_count":14,"visit_count":817,"create_at":"2019-09-23T03:26:35.141Z","author":{"loginname":"YMFL","avatar_url":"https://avatars1.githubusercontent.com/u/18079377?v=4&s=120"}},{"id":"5c9ee97099e62a362ff4166b","author_id":"59302f441e7e75f60c1ad854","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://raw.githubusercontent.com/AttemptWeb/Record/master/Img/record1.png\" alt=\"logo\"></p>\n<hr>\n<p><img src=\"https://img.shields.io/badge/build-passing-brightgreen.svg\" alt=\"passing\">\n<img src=\"https://img.shields.io/badge/License-MIT-brightgreen.svg\" alt=\"MIT\"></p>\n<p><strong>不是技术的创造者，只是技术的搬运工</strong></p>\n<hr>\n<p>推荐 <a href=\"https://coolshell.cn/articles/10804.html\">X-Y Problem 问题</a></p>\n<p>目前整理的模块有下面这些，大部分都是经过学习之后整理，大家可以选择自己感兴趣的查阅：</p>\n<ul>\n<li>\n<p><a href=\"#problem\"><strong>Recommend</strong></a>: 觉得不错的文章或者Blog</p>\n</li>\n<li>\n<p><a href><strong>Css</strong></a>: animation动画、css 特性</p>\n</li>\n<li>\n<p><a href><strong>JavaScript</strong></a>: JS 基础、JS 前端路由、浏览器渲染机制、JS 运行机制事件循环、前端http、Web安全等</p>\n</li>\n<li>\n<p><a href><strong>ReactJs</strong></a>: React 基础、React 解析、React Router、React 服务端渲染</p>\n</li>\n<li>\n<p><a href><strong>DevTool</strong></a>: Git、Webpack、Chrome插件、Travis CI、Puppeteer</p>\n</li>\n<li>\n<p><a href><strong>Server</strong></a>: DB、Koa、Nginx、Centos、Docker</p>\n</li>\n<li>\n<p><a href><strong>Means 资料</strong></a>: JavaScript、React、Node、Nginx、Java、Docker、Computer Science、Data Analysis</p>\n</li>\n<li>\n<p><a href=\"#project-example\"><strong>Project example</strong></a>: 好的项目示例和脚手架</p>\n</li>\n</ul>\n<h3><strong>Recommend</strong></h3>\n<blockquote>\n<p>下面的文章是经过筛选之后放入，有好的文章可以issus哦</p>\n</blockquote>\n<ul>\n<li>\n<p><a href=\"https://github.com/AttemptWeb/Record/issues/6\"><strong>【Markdown】</strong> 传输层的TCP和UDP协议</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/AttemptWeb/Record/issues/12\"><strong>【Markdown】</strong> 图解javascript的this指向</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/AttemptWeb/Record/issues/11\"><strong>【Markdown】</strong> 图解javascript原型链</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/AttemptWeb/Record/blob/master/frame/react/react%E8%A7%A3%E6%9E%90:ReactElement.md\"><strong>【Markdown】</strong> React解析 React.ReactElement(一)</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/AttemptWeb/Record/blob/master/frame/react/react%E8%A7%A3%E6%9E%90:React%20Children.md\"><strong>【Markdown】</strong> React解析 React.Children(二)</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/AttemptWeb/Record/issues/9\"><strong>【Markdown】</strong> React解析 render的FiberRoot(三)</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/EastSummer/wheel_marking/blob/master/question.md\"><strong>【Github】</strong> 一些面试问题的集合</a></p>\n</li>\n<li>\n<p><a href><strong>【Markdown】</strong> js的常见方法</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/HerryLo/Record/blob/master/js/JsMd/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.md\"><strong>【Markdown】</strong> 前端面试题持续更新中</a></p>\n</li>\n<li>\n<p><a href><strong>【Markdown】</strong> 康威定律</a></p>\n</li>\n<li>\n<p><a href=\"https://www.cnblogs.com/kidney/p/6052935.html?utm_source=gold_browser_extension\"><strong>【文章】</strong> vue 的双向绑定</a></p>\n</li>\n<li>\n<p><a href=\"https://coolshell.cn/articles/10804.html\"><strong>【文章】</strong> X-Y Problem 问题</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/ElemeFE/node-interview/tree/master/sections/zh-cn\"><strong>【Github】</strong> 饿了么 Node.js 面试</a></p>\n</li>\n<li>\n<p><a href=\"https://visualgo.net/zh\"><strong>【visualgo】</strong> 数据结构和算法动态可视化</a></p>\n</li>\n<li>\n<p><a href=\"https://i5ting.github.io/modern-nodejs/\"><strong>【Github】</strong> 现代的Node.js 构建服务利器</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/mqyqingfeng/Blog\"><strong>【冴羽博客强推】</strong> JavaScript深入系列、JavaScript专题系列、ES6系列</a></p>\n</li>\n<li>\n<p><a href=\"https://juejin.im/post/5ca0c8aa518825680c7cb44b\"><strong>【Juejin】</strong> [译] JavaScript如何工作：垃圾回收机制 + 常见的4种内存泄漏</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/skyline75489/what-happens-when-zh_CN\"><strong>【Github】</strong> 当你在浏览器中输入 google.com 并且按下回车之后发生了什么</a></p>\n</li>\n</ul>\n<h2><strong>Project example</strong></h2>\n<blockquote>\n<p>说明: 都是别人的项目，只是放个链接</p>\n</blockquote>\n<ul>\n<li>\n<p><a href=\"https://github.com/bailicangdu/vue2-elm\">基于 vue2 + vuex 构建一个具有 45 个页面的大型单页面应用</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/bailicangdu/node-elm\">基于 node.js + Mongodb 构建电商后台系统</a></p>\n</li>\n<li>\n<p><a href=\"https://pan.baidu.com/s/1geQIWHt?qq-pf-to=pcqq.group&amp;errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0#list/path=%2FVue%202.0%20%E9%AB%98%E7%BA%A7%E5%AE%9E%E6%88%98-%E5%BC%80%E5%8F%91%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%9F%B3%E4%B9%90WebApp\">Vue 2.0 高级实战-开发移动端音乐WebApp 百度云视频地址</a></p>\n</li>\n<li>\n<p><a href=\"https://pro.ant.design/\">开箱即用的中台前端/设计解决方案 ANT DESIGN PRO</a></p>\n</li>\n</ul>\n<h2>License</h2>\n<p><a href=\"https://github.com/HerryLo/Record/blob/master/LICENSE\">MIT</a></p>\n<p><strong>有疑问欢迎Issues。Star 是对我们的支持，谢谢大家！！👏👏</strong></p>\n</div>","title":"github的分享仓库 Record","last_reply_at":"2019-09-26T06:24:20.510Z","good":false,"top":false,"reply_count":7,"visit_count":1044,"create_at":"2019-03-30T03:58:40.046Z","author":{"loginname":"lh199507","avatar_url":"https://avatars2.githubusercontent.com/u/20215975?v=4&s=120"}},{"id":"5d85edfb95464514f7ed8d7d","author_id":"5a7a5d505321b5396004ec1e","tab":"share","content":"<div class=\"markdown-text\"><p>发布时间以首个版本发布（0.x）为准。</p>\n<table>\n<thead>\n<tr>\n<th>排名</th>\n<th>框架名称</th>\n<th>star数</th>\n<th>语言</th>\n<th>首个版本发布时间</th>\n<th>github地址</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>express</td>\n<td>45.5k</td>\n<td>js</td>\n<td>2010年1月</td>\n<td><a href=\"https://github.com/expressjs/express\">https://github.com/expressjs/express</a></td>\n<td>star和下载量最高的老牌框架</td>\n</tr>\n<tr>\n<td>2</td>\n<td>koa</td>\n<td>27.4k</td>\n<td>js</td>\n<td>2013年11月</td>\n<td><a href=\"https://github.com/koajs/koa\">https://github.com/koajs/koa</a></td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>sails</td>\n<td>20.9k</td>\n<td>js</td>\n<td>2012年7月</td>\n<td><a href=\"https://github.com/balderdashy/sails\">https://github.com/balderdashy/sails</a></td>\n<td>最早的类ror框架</td>\n</tr>\n<tr>\n<td>4</td>\n<td>nest</td>\n<td>19.8k</td>\n<td>ts</td>\n<td>2017年11月</td>\n<td><a href=\"https://github.com/nestjs/nest\">https://github.com/nestjs/nest</a></td>\n<td>增长最快的框架</td>\n</tr>\n<tr>\n<td>5</td>\n<td>keystone</td>\n<td>14.8k</td>\n<td>js</td>\n<td>2013年7月</td>\n<td><a href=\"https://github.com/keystonejs/keystone\">https://github.com/keystonejs/keystone</a></td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>egg</td>\n<td>13.8k</td>\n<td>js</td>\n<td>2016年7月</td>\n<td><a href=\"https://github.com/eggjs/egg\">https://github.com/eggjs/egg</a></td>\n<td>阿里开源的node.js框架</td>\n</tr>\n<tr>\n<td>7</td>\n<td>loopback</td>\n<td>12.9k</td>\n<td>js/ts</td>\n<td>2013年6月</td>\n<td><a href=\"https://github.com/strongloop/loopback\">https://github.com/strongloop/loopback</a>  &amp; <a href=\"https://github.com/strongloop/loopback-next\">https://github.com/strongloop/loopback-next</a></td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>fastify</td>\n<td>12.1k</td>\n<td>js</td>\n<td>2016年10月</td>\n<td><a href=\"https://github.com/fastify/fastify\">https://github.com/fastify/fastify</a></td>\n<td>性能最好的node.js 框架</td>\n</tr>\n<tr>\n<td>9</td>\n<td>hapi</td>\n<td>11.5k</td>\n<td>js</td>\n<td>2012年8月</td>\n<td><a href=\"https://github.com/hapijs/hapi\">https://github.com/hapijs/hapi</a></td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>pomelo</td>\n<td>10.5k</td>\n<td>js</td>\n<td>2012年12月</td>\n<td><a href=\"https://github.com/NetEase/pomelo\">https://github.com/NetEase/pomelo</a></td>\n<td>游戏框架</td>\n</tr>\n<tr>\n<td>11</td>\n<td>node-restify</td>\n<td>9.5k</td>\n<td>js</td>\n<td>2011年5月</td>\n<td><a href=\"https://github.com/restify/node-restify\">https://github.com/restify/node-restify</a></td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>adonis</td>\n<td>7k</td>\n<td>ts</td>\n<td>2015年10月</td>\n<td><a href=\"https://github.com/adonisjs/adonis-framework\">https://github.com/adonisjs/adonis-framework</a></td>\n<td>类似laravel的框架</td>\n</tr>\n</tbody>\n</table>\n<p>2019年9月26日更新</p>\n</div>","title":"node.js 后端框架star 排名（持续更新）","last_reply_at":"2019-09-26T04:32:13.798Z","good":false,"top":false,"reply_count":3,"visit_count":1863,"create_at":"2019-09-21T09:31:39.764Z","author":{"loginname":"zuohuadong","avatar_url":"https://avatars0.githubusercontent.com/u/11203929?v=4&s=120"}},{"id":"5aca1eab96f344940fbbae80","author_id":"5a4c9ef6ebc575dc49b270ca","tab":"share","content":"<div class=\"markdown-text\"><h1>nuxt-cnode</h1>\n<blockquote>\n<p>基于vue的nuxt框架仿的cnode社区服务端渲染，主要是为了seo优化以及首屏加载速度</p>\n</blockquote>\n<p>线上地址 <a href=\"http://nuxt-cnode.foreversnsd.cn/\">http://nuxt-cnode.foreversnsd.cn</a>\ngithub地址 <a href=\"https://github.com/Kim09AI/nuxt-cnode\">https://github.com/Kim09AI/nuxt-cnode</a></p>\n<h3>技术栈</h3>\n<ul>\n<li>vue</li>\n<li>vue-router</li>\n<li>vuex</li>\n<li>nuxt</li>\n<li>axios</li>\n<li>simplemde</li>\n<li>ES6/7</li>\n<li>stylus</li>\n</ul>\n<h3>目录结构</h3>\n<pre class=\"prettyprint\"><code>├─npm-shrinkwrap.json\n├─nuxt.config.js                # nuxt配置文件\n├─package.json\n├─README.md\n├─utils\n|   ├─axios.js                  # axios封装\n|   ├─index.js                  # 工具函数\n|   └scroll.js                  # 滚动条操作函数\n├─store                         # store\n|   ├─actions.js\n|   ├─getters.js\n|   ├─index.js\n|   ├─mutation-types.js\n|   ├─mutations.js\n|   ├─README.md\n|   └state.js\n├─static                        # 静态资源\n|   ├─favicon.ico\n|   └README.md\n├─plugins                       # vue实例化之前执行的插件\n|    ├─component.js             # 注册全局组件\n|    ├─filter.js                # 注册全局filter\n|    ├─README.md                \n|    └ssrAccessToken.js         # 服务端渲染时保存access_token,供服务端请求时的api获取\n├─pages                         # 页面级组件\n|   ├─index.vue                 # 首页\n|   ├─login.vue                 # 登录页\n|   ├─README.md \n|   ├─user\n|   |  ├─messages.vue           # 未读消息页\n|   |  ├─_id\n|   |  |  ├─index.vue           # 用户信息页\n|   |  |  └collections.vue      # 用户收藏的主题页\n|   ├─topic\n|   |   ├─create.vue            # topic创建页，复用为编辑页\n|   |   ├─_id\n|   |   |  └index.vue           # topic详情页\n├─mixins                        # mixins\n|   └index.js\n├─middleware                    # 中间件，页面渲染之前执行\n|     ├─auth.js                 # 用户权限中间件\n|     ├─checkRoute.js           # 主要是对404页面的重定向\n|     └README.md\n├─layouts                       # 布局\n|    ├─default.vue\n|    └README.md\n├─filters                       # 全局filter\n|    └index.js\n├─components\n|     ├─alert.vue               # 提示组件\n|     ├─backTop.vue\n|     ├─clientPanel.vue\n|     ├─commentList.vue         # 评论列表\n|     ├─commonFooter.vue\n|     ├─commonHeader.vue\n|     ├─mainLayout.vue          # 页面内的主布局，划分左右两栏\n|     ├─markdown.vue            # 基于simplemde封装的组件\n|     ├─messageList.vue         # 消息列表\n|     ├─pageNav.vue             # 分页组件\n|     ├─panel.vue\n|     ├─README.md\n|     ├─tabHeader.vue\n|     ├─topicCreatePanel.vue\n|     ├─topicList.vue           # 文章列表\n|     └userInfoPanel.vue\n├─assets\n|   ├─README.md\n|   ├─css\n|   |  ├─common.styl\n|   |  ├─icon.styl\n|   |  ├─index.styl\n|   |  ├─mixin.styl\n|   |  ├─reset.styl\n|   |  └simplemdecover.styl\n├─api                           # 请求api\n|  └index.js\n</code></pre><h3>实现的功能</h3>\n<ul>\n<li>首页</li>\n<li>topic详情页</li>\n<li>新建topic</li>\n<li>编辑topic</li>\n<li>收藏topic</li>\n<li>用户收藏的topic</li>\n<li>取消收藏topic</li>\n<li>新建topic的评论</li>\n<li>新建评论的评论</li>\n<li>点赞评论</li>\n<li>个人信息及用户信息</li>\n<li>登录/退出</li>\n<li>未读消息页</li>\n</ul>\n<h3>cookie的共享</h3>\n<p>只要做服务端渲染，不管是vue还是react，都必然会遇到cookie共享的问题，因为在服务器上不会为请求自动带cookie,所以需要手动来为请求带上cookie，以下方法主要是借鉴vue-srr导出一个创建app、router、store工厂函数的方法，导出一个创建axios的工厂函数，然后把创建的axios实例注入store,建立store与axios一一对应的关系，\n然后就可以通过store.$axios或state.$axios去请求就会自动带cookie了</p>\n<h4>首先获取cookie中的东西放到store.state</h4>\n<pre class=\"prettyprint language-js\"><code>export const nuxtServerInit = async ({ commit, dispatch, state }, { req }) =&gt; {\n    let accessToken = parseCookieByName(req.headers.cookie, &#x27;access_token&#x27;)\n\n    if (!!accessToken) {\n        try {\n            let res = await state.$axios.checkAccesstoken(accessToken)\n\n            if (res.success) {\n                let userDetail = await state.$axios.getUserDetail(res.loginname)\n                userDetail.data.id = res.id\n\n                &#x2F;&#x2F; 提交登录状态及用户信息\n                dispatch(&#x27;setUserInfo&#x27;, {\n                    loginState: true,\n                    user: userDetail.data,\n                    accessToken: accessToken\n                })\n            }\n        } catch (e) {\n            console.log(&#x27;fail in nuxtServerInit&#x27;, e.message)\n        }\n    }\n}\n</code></pre><h4>导出一个创建axios的工厂函数</h4>\n<pre class=\"prettyprint language-js\"><code>class CreateAxios extends Api {\n    constructor(store) {\n        super(store)\n        this.store = store\n    }\n\n    getAccessToken() {\n        return this.store.state.accessToken\n    }\n\n    get(url, config = {}) {\n        let accessToken = this.getAccessToken()\n\n        config.params = config.params || {}\n        accessToken &amp;&amp; (config.params.accesstoken = accessToken)\n\n        return axios.get(url, config)\n    }\n\n    post(url, data = {}, config = {}) {\n        let accessToken = this.getAccessToken()\n\n        accessToken &amp;&amp; (data.accesstoken = accessToken)\n\n        return axios.post(url, qs.stringify(data), config)\n    }\n\n    &#x2F;&#x2F; 返回服务端渲染结果时会用JSON.stringify对state处理,因为store与$axios实例循环引用会导致无法序列化\n    &#x2F;&#x2F; 添加toJSON绕过JSON.stringify\n    toJSON() {}\n}\n\nexport default CreateAxios\n</code></pre><h4>在创建store时创建axios并把axios注入store</h4>\n<pre class=\"prettyprint language-js\"><code>const createStore = () =&gt; {\n    let store = new Vuex.Store({\n        state,\n        getters,\n        mutations,\n        actions\n    })\n\n    store.$axios = store.state.$axios =  new CreateAxios(store)\n\n    if (process.browser) {\n        let replaceState = store.replaceState.bind(store)\n        store.replaceState = (...args) =&gt; {\n            replaceState(...args)\n            store.state.$axios = store.$axios\n            replaceState = null\n        }\n    }\n\n    return store\n}\n\nexport default createStore\n</code></pre><p>之后就可以在asyncData函数中使用store.$axios、在组件内使用this.$store.$axios、在axtion中使用state.$axios或rootState.$axios发起请求了，这些请求都会自动的带上cookie中的东西</p>\n<blockquote>\n<p>若该项目对你有帮助，欢迎 star</p>\n</blockquote>\n<h2>Build Setup</h2>\n<pre class=\"prettyprint language- bash\"><code># install dependencies\n$ npm install # Or yarn install\n\n# serve with hot reload at localhost:3000\n$ npm run dev\n\n# build for production and launch server\n$ npm run build\n$ npm start\n\n# generate static project\n$ npm run generate\n</code></pre><p>For detailed explanation on how things work, checkout the <a href=\"https://github.com/nuxt/nuxt.js\">Nuxt.js docs</a>.</p>\n</div>","title":"基于vue的nuxt框架cnode社区服务端渲染","last_reply_at":"2019-09-26T04:21:01.758Z","good":false,"top":false,"reply_count":7,"visit_count":2284,"create_at":"2018-04-08T13:52:43.150Z","author":{"loginname":"Kim09AI","avatar_url":"https://avatars1.githubusercontent.com/u/23711127?v=4&s=120"}},{"id":"5d8af8b8e86cfb0d2a6459a5","author_id":"590d49aeba8670562a40ed64","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FtAJylES9mPxDcEiWWCGyH9C1t43\" alt=\"1568861665088-5963fe08-47a2-43cc-8ada-490dd1b6bcba.png\"></p>\n<p>相信作为前端的我们对Node都比较熟悉，它以异步非阻塞IO模型闻名，特别擅长处理IO密集型的任务，这种优势是依靠Libuv实现的，想要更好的理解Node，学习Libuv是一个不错的途径。本文作为Libuv的第一篇文章，主要学习它的队列实现。为什么先从队列开始学习呢？原因有2点，一是它的代码少，容易学；二是作为基础结构，它被广泛的应用在Libuv中。</p>\n<h3>起航</h3>\n<p>学习的第一步，当然是获取源码写demo了。源码可以从github上获取，地址为<a href=\"https://github.com/libuv/libuv\">libuv</a>。队列的代码在源码中也很容易找到queue.h：</p>\n<p><img src=\"//static.cnodejs.org/Fhj4fF5JAylQ9teDHqUvO-tasEsA\" alt=\"image.png\"></p>\n<p>在写demo之前，先了解一下Libuv中队列的结构，它是通过带有头节点的双向循环列表实现的，具体结构如下图所示：</p>\n<p><img src=\"//static.cnodejs.org/FgBJj-KfYeyCY7rvET34DmPjFJPu\" alt=\"image.png\"></p>\n<p>图中有几个图案需要解释一下：</p>\n<p><img src=\"//static.cnodejs.org/Fil7Of8dz1d4KX2SbVDBGbZL5ws3\" alt=\"image.png\"></p>\n<p>上面的图案我们就叫做队列指针吧，可以认为它是一个具有2个元素的数组，第一个元素指向下一个队列元素，第二个元素指向上一个队列元素，它就是Libuv中队列的核心。</p>\n<p><img src=\"//static.cnodejs.org/FhXA7IV5LmEeL-hZzS51fT_x5_4D\" alt=\"image.png\"></p>\n<p>上面struct可以认为是JavaScript中的对象，他的一个属性就是队列指针，用来链接队列中的其他元素，当然struct可以包含任何其他属性。从这里我们可以看出Libuv的队列是一个通用实现，可以用在任何对象上。</p>\n<h3>demo</h3>\n<p>好了，了解了基本结构，让我们写个demo熟悉一下api吧。</p>\n<p><img src=\"//static.cnodejs.org/Fl6FThA5Bu7o9kyFQKvQmeINWe5w\" alt=\"image.png\"></p>\n<p>demo的输出如下：</p>\n<p><img src=\"//static.cnodejs.org/FpRVBhufcS9NaHMaLpKKLQPcGlWu\" alt=\"image.png\"></p>\n<h3>源码分析</h3>\n<p>初看queue.h，可以发现Libuv的队列是通过宏实现的，对于不了解宏的同学，可以参考https://www.runoob.com/cprogramming/c-preprocessors.html。上面demo用到了QUEUE_INIT、QUEUE_INSERT_TAIL、QUEUE_FOREACH、QUEUE_DATA，在介绍这几个宏之前，我们先看下面的代码。</p>\n<p><img src=\"//static.cnodejs.org/FmoRVPIN0gYutoXqeXQ2GaWBKETO\" alt=\"image.png\"></p>\n<p>上面代码定义了一个类型QUEUE——队列，它是一个包含两个元素的数组，数组中每个元素的类型为void *，可以用来放任何类型的指针。QUEUE_NEXT用来获取队列中下一个元素、QUEUE_PREV是用来获取队列中上一个元素，传参q的类型为QUEUE *，这两个宏很类似，所以只需要分析其中一个就好了，那就分析QUEUE_NEXT吧。</p>\n<p><img src=\"//static.cnodejs.org/Flm1mGMPA6Pch6z9tiW6oehD1_y-\" alt=\"image.png\"></p>\n<p>通过获取变量a的地址就可以到q，那么QUEUE_NEXT就可以转为图中形式，按理说QUEUE_NEXT直接写为(*(q))[0] 不就行了吗，为啥还需要对其取地址，然后转为QUEUE **后再取值呢？原因这里有两个，第一个原因是因为参数q的类型并不一定是QUEUE *，需要进行类型转换；第二个原因是将其变成左值，保证其能赋值，所谓的左值可以被认为是变量，能够将数据保存进去。</p>\n<p>QUEUE_PREV_NEXT和QUEUE_NEXT_PREV两个宏的形式也差不多，所以分析其中一个就行了，就QUEUE_PREV_NEXT吧。从字面上理解，获取上一个元素的下一个元素，那不就是自身吗，为什么需要有这么奇怪的操作？这么理解其实是一个误导，潜意识下我们可能把这个宏用作取值了，这个宏其实是用来进行赋值的，对上一个元素的[0]进行赋值，这也呼应了上面QUEUE_NEXT、QUEUE_PREV写那么复杂的第二个原因——左值。QUEUE_PREV_NEXT本质上可以用下图表示。</p>\n<p><img src=\"//static.cnodejs.org/FofXnbKIMB579g1675K6LFl3f3FI\" alt=\"image.png\"></p>\n<p>好了，分析了上面的内容，就可以对demo中使用的几个宏进行分析了。</p>\n<p><strong>QUEUE_INIT</strong></p>\n<p><img src=\"//static.cnodejs.org/FsGJl8TBGe4gOSU_lej9frmH2d-O\" alt=\"image.png\"></p>\n<p>QUEUE_INIT可以用下图表示，将[0]、[1]上的元素都赋予自身。</p>\n<p><img src=\"//static.cnodejs.org/Flir0gaBtfUju6rP_tIO5EqLaaB9\" alt=\"image.png\"></p>\n<p>这里有一点需要说明，为什么这个宏需要用do while包裹着？原因是这个宏有两条语句，需要将他们变成一个整体，不包裹可能会出现问题，比如下面代码中的for因为没有{}包裹，导致QUEUE_PREV就不在for循环体内了。</p>\n<p><img src=\"//static.cnodejs.org/FpGGnOG7prQBa-mZa-VJd0Ed5c6j\" alt=\"image.png\"></p>\n<p><strong>QUEUE_INSERT_TAIL</strong></p>\n<p><img src=\"//static.cnodejs.org/FppdDKARS82DoMObIStJbqOEy2h0\" alt=\"image.png\"></p>\n<p>QUEUE_INSERT_TAIL就是简单的将元素q加入到队列h的尾部，具体过程如下图所示，上面部分表示将元素q插入到队列h中，下面表示插好的队列。其中红色的线表示新加的，灰色的线表示去掉的，数字表示顺序。</p>\n<p><img src=\"//static.cnodejs.org/Fjl53ZxYlW1uJV75WWvqwUu7zylO\" alt=\"image.png\"></p>\n<p><strong>QUEUE_FOREACH</strong></p>\n<p><img src=\"//static.cnodejs.org/FvHWq1HmYSumoxPV4EIVH5pbKg9S\" alt=\"image.png\"></p>\n<p>QUEUE_FOREACH通过for循环不断取队列h中的元素，将其赋给q。这里有意思的是，只有for循环的头部，却没有for循环的body，其实body是在使用的时候写，比如在demo中我们是这么写的：</p>\n<p><img src=\"//static.cnodejs.org/FtpFPxXwiQpi7xYyd7dJcFyD9MVt\" alt=\"image.png\"></p>\n<p><strong>QUEUE_DATA</strong></p>\n<p>可以看到在demo中我们用QUEUE_FOREACH遍历队列，可是我们拿到是只是队列的指针，那我们如何拿到work对象的内容呢？这个就得靠QUEUE_DATA了。</p>\n<p><img src=\"//static.cnodejs.org/Fl9UOg_e6JSvDfLxSyF-8LswC2Ge\" alt=\"image.png\"></p>\n<p>看起来好像很复杂的样子，先看下offsetof，它是用来获取属性filed在指定类型type的位置偏差（以字节来算），demo中的代码其实就是获取属性q在Work中的位置偏差。然后通过用q在内存中的地址减去该偏差就能得到Work对象在内存中的初始位置，通过类型转化就能到Work对象的指针，这样就能访问数据了，具体可以参考下图：</p>\n<p><img src=\"//static.cnodejs.org/FiXXLcG3voLq9DKTkRwETwgWrvc7\" alt=\"image.png\"></p>\n<p>好了demo中用到的几个宏已经全部讲完了，队列其实还有一些其他的宏，这些宏都比较简单，这里也就不分析了，有兴趣的同学可以自己看下源码。</p>\n<h3>总结</h3>\n<p>作为前端的我们，可能对于c语言不熟悉，特别是内存管理和宏这块，如果能看完，真的是很不容易。本文是libuv学习的第一篇，接下来我会定期写一些关于Libuv的其他文章，比如目前真正写libuv中线程相关的内容，如果有兴趣的话，欢迎关注我们。</p>\n<p><img src=\"//static.cnodejs.org/FguIgpBjpfZzkO2oFXhIPuKQNUdi\" alt=\"image.png\"></p>\n</div>","title":"Libuv学习——队列","last_reply_at":"2019-09-26T01:38:13.450Z","good":false,"top":false,"reply_count":3,"visit_count":378,"create_at":"2019-09-25T05:18:48.809Z","author":{"loginname":"wanglei20116527","avatar_url":"https://avatars2.githubusercontent.com/u/5023412?v=4&s=120"}},{"id":"5d8c0df7e86cfb0d2a645c61","author_id":"5b0eaaf38a4f51e140d9437d","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>没有人不爱惜他的生命，但很少人珍视他的时间。 —— 梁实秋</p>\n</blockquote>\n<p>Docker 自 2013 年发布至今一直备受关注，从招聘面试角度来看有些职位对于了解 Docker、K8S 这些也有一些加分项，同时学习 Docker 也是后续学习 K8S 的基础，但是对于 Docker 很多人也需并不了解，其实 Docker 也并没有那么难，本文从 Docker 入门到应用实践为大家进行讲解，中间也列举了很多实例，希望能帮助大家更好的理解。</p>\n<p><strong>作者简介</strong>：五月君，Nodejs Developer，热爱技术、喜欢分享的 90 后青年，公众号「Nodejs技术栈」，Github 开源项目 <a href=\"https://www.nodejs.red\"> https://www.nodejs.red</a></p>\n<h2>快速导航</h2>\n<ul>\n<li><a href=\"#Docker%E5%88%9D%E8%AF%86\">Docker 初识</a></li>\n<li><a href=\"#Docker%E5%AE%89%E8%A3%85\">Docker 安装</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E5%88%9D%E6%8E%A2\">镜像构建初探</a></li>\n<li><a href=\"#Dockerfile%E5%AE%9E%E8%B7%B5\">Dockerfile 实践</a></li>\n<li><a href=\"#Registry%E5%AE%9E%E8%B7%B5\">Registry 实践</a></li>\n<li><a href=\"#DockerCompose%E5%AE%9E%E8%B7%B5\">Docker Compose 实践</a></li>\n</ul>\n<p><strong>本篇 Docker 入门到实践路线图如下所示</strong></p>\n<p><img src=\"//img.mukewang.com/5d8b483800014fdf23380530.png\" alt=\"图片描述\"></p>\n<h2>Docker初识</h2>\n<h4>为什么要使用 Docker</h4>\n<p>Docker 可以将应用以集装箱的方式进行打包，通过镜像的方式可以实现在不同的环境下进行快速部署，在团队中还可实现一次打包，多次共享，使用 Docker 可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。</p>\n<p>例如，我们在本地将编译测试通过的程序打包成镜像，可以快速的在服务器环境中进行部署，有时也能解决不同的开发环境造成的问题 “明明我本地是好的，但是一到服务器就不行”。</p>\n<p>为什么要使用 Docker？总结下来其有以下优点：</p>\n<ul>\n<li>高效的利用系统资源（节约成本）</li>\n<li>持续交付与部署（敏捷）</li>\n<li>多平台的迁移更容易（可移植性）</li>\n<li>容易的沙箱机制（安全性）</li>\n</ul>\n<h4>Docker 架构一瞥</h4>\n<p>中间部位为我们进行 Docker 操作的宿主机，其运行了一个 Docker daemon 的核心守护程序，负责构建、运行和分发 Docker 容器。</p>\n<p>左边为 Docker 客户端，其与 Docker 守护进程进行通信，客户端会将 build、pull、run 命令发送到 Docker 守护进程进行执行。</p>\n<p>右边为 Docler 注册表存储 Docker 镜像，是一个所有 Docker 用户共享 Docker 镜像的服务，Docker daemon 与之进行交互。</p>\n<p><img src=\"//img.mukewang.com/5d8b488700019f5c17340920.png\" alt=\"图片描述\"></p>\n<h4>Docker 镜像与容器概述</h4>\n<p>参考 <a href=\"https://docs.docker.com/engine/docker-overview/\">https://docs.docker.com/engine/docker-overview/</a></p>\n<p><strong>什么是 Docker 镜像</strong></p>\n<p>Docker 会把应用程序及依赖打包进镜像（Images）里，提供了容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等），通过这个镜像文件可生成 Docker 容器。</p>\n<p>例如：这个镜像文件包含了一个完整的 Ubuntu 系统，我们可以在 Ubuntu 镜像基础之上安装了 Redis、Mysql 等其它应用程序，可以回顾下 <a href=\"#Docker%E6%9E%B6%E6%9E%84%E4%B8%80%E7%9E%A5\">Docker 架构一瞥</a> 在 DOCKER_HOST 里面有个 images。</p>\n<p>另外在制作好镜像文件之后可以拷贝到其它机器使用，它是通用的，镜像的制作可以基于 Dockerfile 构建后面会讲解。</p>\n<p><strong>什么是 Docker 容器</strong></p>\n<p><strong>容器是镜像的可运行实例</strong>，你可以使用 Docker API 创建、启动、停止、移动或删除它，</p>\n<p>在默认情况下，容器与其它容器及其主机是隔离的，拥有自己的独立进程空间、网络配置。</p>\n<p>容器由其镜像以及在创建或启动容器时提供的任何配置选项定义。当容器被删除时，对其状态的任何未存储在持久存储中的更改都会消失。</p>\n<h2>Docker安装</h2>\n<p>Docker 是一个开源的商业产品，提供了社区版（CE）和企业版（EE），以下也都是基于企业版进行介绍，我这里操作系统采用的 Linux 下 Ubuntu 系统，更多安装方式也可参照官网安装指南 <a href=\"https://docs.docker.com/install/\">https://docs.docker.com/install/</a></p>\n<h4>更改 docker 源</h4>\n<p>这个看情况，因为 Docker 的源在国外，国内访问速度可能会不稳定，有需要的可以按照以下步骤更换为国内源</p>\n<ul>\n<li>编辑 /etc/docker/daemon.json 文件，输入 docker-cn 镜像源地址</li>\n</ul>\n<pre class=\"prettyprint\"><code>$ sudo vim &#x2F;etc&#x2F;docker&#x2F;daemon.json\n\n{\n  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;]\n}\n</code></pre><ul>\n<li>重启 Docker 服务</li>\n</ul>\n<pre class=\"prettyprint\"><code>$ sudo service docker restart\n</code></pre><h4>设置存储库</h4>\n<ol>\n<li>更新 apt 软件包缓存</li>\n</ol>\n<pre class=\"prettyprint language-bash\"><code>sudo apt-get update\n</code></pre><ol>\n<li>在机器上首次安装的需先设置 Docker 存储库，由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。</li>\n</ol>\n<pre class=\"prettyprint language-bash\"><code>$ sudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    gnupg-agent \\\n    software-properties-common\n</code></pre><ol>\n<li>添加 Docker 的官方 GPG 密钥</li>\n</ol>\n<pre class=\"prettyprint language-bash\"><code>$ curl -fsSL https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add -\n</code></pre><ol>\n<li>向 source.list 中添加 Docker 软件源</li>\n</ol>\n<pre class=\"prettyprint language-bash\"><code>$ sudo add-apt-repository \\\n   &quot;deb [arch=amd64] https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu \\\n   $(lsb_release -cs) \\\n   stable&quot;\n</code></pre><h4>安装 Docker EC（社区版）</h4>\n<ol>\n<li>更新 apt 软件包缓存</li>\n</ol>\n<pre class=\"prettyprint language-bash\"><code>sudo apt-get update\n</code></pre><ol>\n<li>安装</li>\n</ol>\n<pre class=\"prettyprint language-shell\"><code>sudo apt-get install docker-ce docker-ce-cli containerd.io\n</code></pre><p>执行以下命令使用脚本自动安装，这也是最简化的安装流程，它会检测你当前使用的 Linux 版本，选择合适的安装包进行安装，</p>\n<pre class=\"prettyprint language-shell\"><code>sudo wget -qO- https:&#x2F;&#x2F;get.docker.com | sh\n</code></pre><h4>添加 Docker 用户组</h4>\n<p>由于 Docker 操作需要拥有 root 权限，为避免每次都输入 sudo，可以把用户加入 Docker 用户组，执行以下命令</p>\n<pre class=\"prettyprint language-shell\"><code># https:&#x2F;&#x2F;docs.docker.com&#x2F;install&#x2F;linux&#x2F;linux-postinstall&#x2F;#manage-docker-as-a-non-root-user\n$ sudo usermod -aG docker $USER\n</code></pre><h4>验证</h4>\n<p>安装完成后，运行下面的命令，验证是否安装成功</p>\n<pre class=\"prettyprint\"><code>$ docker -v\nDocker version 19.03.2, build 6a30dfc\n</code></pre><h2>镜像构建初探</h2>\n<p>上面对 Docker 的镜像和容器做了简要概述，有个初步的了解之后，再来看下 Docker 镜像和容器的实践。</p>\n<h4>抓取 image 文件到本地</h4>\n<p>hello-world 为镜像名字，docker image pull 为抓取镜像命令，Docker 官方提供的 image 文件都放在 library 默认组里，library/hello-world 也就为 image 文件的位置。</p>\n<pre class=\"prettyprint language-bash\"><code>$ docker image pull hello-world\n# 以下为抓取过程中的日志信息\nUsing default tag: latest\nlatest: Pulling from library&#x2F;hello-world\n1b930d010525: Pull complete \nDigest: sha256:451ce787d12369c5df2a32c85e5a03d52cbcef6eb3586dd03075f3034f10adcd\nStatus: Downloaded newer image for hello-world:latest\ndocker.io&#x2F;library&#x2F;hello-world:latest\n</code></pre><h4>查看 image 文件列表</h4>\n<p>image 文件抓取成功通过 docker images 或 docker image ls 命令查看当前都有哪些镜像</p>\n<pre class=\"prettyprint language-bash\"><code>$ docker image ls\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nhello-world         latest              fce289e99eb9        8 months ago        1.84kB\n</code></pre><h4>运行 image 文件</h4>\n<p>执行 <code>docker container run</code> 命令会生成一个正在运行的容器实例，另外 <code>docker container run</code> 发现本地没有指定的 image 文件，其自身还有自动抓取 image 文件功能，就是上面讲解的 <code>docker image pull</code> 命令</p>\n<pre class=\"prettyprint language-bash\"><code>$ docker container run hello-world\n\nHello from Docker!\n\n# 以下内容省略\n...\n</code></pre><h4>查看容器列表</h4>\n<p>使用 <code>docker ps</code> 或 <code>docker container ls</code> 命令用来查看正在运行的容器列表，这个时候是没有正在运行的容器实例的，因为在以上 <code>docker container run hello-world</code> 命令执行之后 <code>hello-world</code> 就会停止，容器也会随着自动停止，但并不是所有的容器运行之后也都会停止的，例如 Nginx 后面会进行实践。</p>\n<pre class=\"prettyprint\"><code>$ docker ps\n</code></pre><p>通过 <code>docker ps --all</code> 或 <code>docker container ls --all</code> 命令可以查看所有的容器实例，包含已经停止的</p>\n<pre class=\"prettyprint\"><code>$ docker ps --all\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES\na662ec198a83        hello-world         &quot;&#x2F;hello&quot;            10 minutes ago      Exited (0) 10 minutes ago                       exciting_wing\n</code></pre><h4>构建一个 Nginx 镜像</h4>\n<p>以下命令会用 nginx 镜像启动一个容器，命名为 nginxserver，并映射到 8081 端口</p>\n<pre class=\"prettyprint language-bash\"><code>$ docker container run --name nginxserver -d -p 8081:80 nginx\n</code></pre><p>好了，我们现在就可以使用 <a href=\"http://localhost:8081/\">http://localhost:8081/</a> 来访问这个 Nginx 服务器，由于我这里是在虚拟机上安装的 Docker 因此要使用我的虚拟机地址 <a href=\"http://192.168.6.128:8081/\">http://192.168.6.128:8081/</a> 进行访问，同样如果你是在虚拟机、云服务器上安装的 Docker 也要使用相应的 ip 来访问，如果是在本机直接 localhost 就可以。以下为 Nginx 默认的欢迎页面。</p>\n<p><img src=\"//img.mukewang.com/5d8b48a90001418e14120654.png\" alt=\"图片描述\"></p>\n<p>再分别看下目前的 image 列表和正在运行的容器</p>\n<pre class=\"prettyprint language-bash\"><code>$ docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nnginx               latest              5a3221f0137b        3 weeks ago         126MB\nhello-world         latest              fce289e99eb9        8 months ago        1.84kB\n\n$ docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES\nb7bf26745b3f        nginx               &quot;nginx -g &#x27;daemon of…&quot;   23 minutes ago      Up 23 minutes       0.0.0.0:8081-&gt;80&#x2F;tcp   nginxserver\n</code></pre><h4>终止容器</h4>\n<p>通过 <code>docker container kill [containID]</code> 命令终止正在运行的容器</p>\n<pre class=\"prettyprint language-bash\"><code># docker container kill [containID]\n$ docker container kill b7bf26745b3f\n</code></pre><h4>删除容器文件</h4>\n<p>上面的终止容器并不会删除容器文件，仅仅是容器停止运行，通过 docker ps --all 命令查看所有的容器列表</p>\n<pre class=\"prettyprint language-bash\"><code>$ docker ps --all\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                            PORTS               NAMES\nb7bf26745b3f        nginx               &quot;nginx -g &#x27;daemon of…&quot;   29 minutes ago      Exited (137) About a minute ago                       nginxserver\na662ec198a83        hello-world         &quot;&#x2F;hello&quot;                 49 minutes ago      Exited (0) 49 minutes ago                             exciting_wing\n</code></pre><p>由于已经终止容器文件依然会占据着我们的磁盘空间，在不使用的情况可通过 <code>docker container rm [containerID]</code> 命令删除</p>\n<pre class=\"prettyprint\"><code>$ docker container rm b7bf26745b3f a662ec198a83\n</code></pre><p>执行以上命令之后，再使用 <code>docker ps --all</code> 命令，此时容器列表就为空了。</p>\n<h4>删除镜像文件</h4>\n<p>同样删除一个镜像文件也很简单执行 <code>docker rmi [imageID]</code> 命令即可</p>\n<pre class=\"prettyprint\"><code>$ docker rmi 5a3221f0137b fce289e99eb9\n</code></pre><h2>Dockerfile实践</h2>\n<p>Dockerfile 是由一系列的参数、命令构成的可执行脚本，用来构建、定制 Docker 镜像。本节通过一个 Node.js 的简单项目为例，介绍下如何编写 Dockerfile 文件、如何在 Docker 容器里运行 Node.js 项目。</p>\n<h4>Nodejs项目准备</h4>\n<p>/usr/src/nodejs/hello-docker 目录下新建 app.js</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; &#x2F;usr&#x2F;src&#x2F;nodejs&#x2F;hello-docker&#x2F;app.js\nconst http = require(&#x27;http&#x27;);\nconst PORT = 30010;\n\nconst server = http.createServer((req, res) =&gt; {\n    res.end(&#x27;Hello Docker&#x27;);\n})\n\nserver.listen(PORT, () =&gt; {\n    console.log(&#x27;Running on http:&#x2F;&#x2F;localhost:&#x27;, PORT);\n});\n</code></pre><p>/usr/src/nodejs/hello-docker 目录下新建 package.json</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; &#x2F;usr&#x2F;src&#x2F;nodejs&#x2F;hello-docker&#x2F;package.json\n{ \n  &quot;name&quot;: &quot;hello-docker&quot;, \n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;, \n  &quot;author&quot;: &quot;May&quot;,\n  &quot;main&quot;: &quot;app.js&quot;,   \n  &quot;scripts&quot;: { \n    &quot;start&quot;: &quot;node app.js&quot;\n  },\n  &quot;dependencies&quot;: { \n    \n  }\n}\n</code></pre><h4>Dockerfile 编写</h4>\n<p>首先在项目根目录下创建 .dockerignore 文件，把不需要打包进 Docker Image 里的文件进行过滤</p>\n<pre class=\"prettyprint language-shell\"><code># &#x2F;usr&#x2F;src&#x2F;nodejs&#x2F;hello-docker&#x2F;.dockerignore\n.git\nnode_modules\n</code></pre><p><strong>Dockerfile</strong></p>\n<p>项目根目录下新建 Dockerfile 文件</p>\n<pre class=\"prettyprint language-Dockerfile\"><code># &#x2F;usr&#x2F;src&#x2F;nodejs&#x2F;hello-docker&#x2F;Dockerfile\n\nFROM node:10.0\n\n# 在容器中创建一个目录\nRUN mkdir -p &#x2F;usr&#x2F;src&#x2F;nodejs&#x2F;\n\n# 定位到容器的工作目录\nWORKDIR &#x2F;usr&#x2F;src&#x2F;nodejs&#x2F;\n\n# RUN&#x2F;COPY 是分层的，package.json 提前，只要没修改，就不会重新安装包\nCOPY package.json &#x2F;usr&#x2F;src&#x2F;app&#x2F;package.json\nRUN cd &#x2F;usr&#x2F;src&#x2F;app&#x2F;\nRUN npm i\n\n# 把当前目录下的所有文件拷贝到 Image 的 &#x2F;usr&#x2F;src&#x2F;nodejs&#x2F; 目录下\nCOPY . &#x2F;usr&#x2F;src&#x2F;nodejs&#x2F;\n\n\nEXPOSE 30010\nCMD npm start\n</code></pre><ul>\n<li>FROM：FROM 是构建镜像的基础源镜像，该 Image 文件继承官方的 node image</li>\n<li>RUN：后面跟的是在容器中执行的命令</li>\n<li>WORKDIR：容器的工作目录</li>\n<li>COPY：拷贝文件至容器的工作目录下，.dockerignore 指定的文件不会拷贝</li>\n<li>EXPOSE：将容器内的某个端口导出供外部访问</li>\n<li>CMD：Dockerfile 执行写一个 CMD 否则后面的会被覆盖，CMD 后面的命令是容器每次启动执行的命令，多个命令之间可以使用 &amp;&amp; 链接，例如 CMD git pull &amp;&amp; npm start</li>\n</ul>\n<h4>构建 hello-docker 镜像文件</h4>\n<p>Dockerfile 文件创建好之后，使用 <code>docker image build</code> 命令创建镜像文件，-t 参数用来指定镜像的文件名称，最后一个 <strong>.</strong> 也不要省略，表示 Dockerfile 文件的所在目录</p>\n<pre class=\"prettyprint\"><code>$ docker image build -t hello-docker .\n</code></pre><p>执行以上命令之后，我们来查看下新生成的镜像文件 hello-docker</p>\n<pre class=\"prettyprint\"><code>$ docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nhello-docker        latest              6b1c2775591e        4 minutes ago       675MB\nnode                10.0                1c1272350058        16 months ago       675MB\n</code></pre><h4>运行容器</h4>\n<p>镜像构建成功之后通过 docker container run 命令来生成一个容器，几个参数说明：</p>\n<ul>\n<li>-d：表明容器的运行模式在后台</li>\n<li>-p：端口映射，将本机的 30000 端口映射到容器的 30010 端口，这样在外网就可通过 30000 端口访问到我们的服务</li>\n<li>hello-docker：为我们的镜像名字</li>\n</ul>\n<pre class=\"prettyprint\"><code>$ docker container run -d -p 30000:30010 hello-docker\n</code></pre><p>执行以上命令之后通过 docker ps 查看我们刚刚运行的容器信息</p>\n<pre class=\"prettyprint\"><code>$ docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                      NAMES\nc2891d477edf        hello-docker        &quot;&#x2F;bin&#x2F;sh -c &#x27;npm sta…&quot;   15 seconds ago      Up 14 seconds       0.0.0.0:30000-&gt;30010&#x2F;tcp   pedantic_mestorf\n</code></pre><p>不出什么意外，此时我们的 Node.js 服务已经运行在 Docker 容器的虚拟环境里了，访问 <code>curl http://localhost:30000</code> 可以进行测试。</p>\n<pre class=\"prettyprint\"><code>$ curl http:&#x2F;&#x2F;localhost:30000\nHello Docker\n</code></pre><h4>检查日志</h4>\n<p>查看运行日志，“c2891d477edf” 为容器 ID</p>\n<pre class=\"prettyprint language-bash\"><code>$ docker logs -f c2891d477edf\n\n&gt; hello-docker@1.0.0 start &#x2F;usr&#x2F;src&#x2F;nodejs&#x2F;hello-docker\n&gt; node app.js\n\nRunning on http:&#x2F;&#x2F;localhost: 30010\n</code></pre><h4>容器进入退出</h4>\n<p>为了方便排查内部容器文件，可以通过 <strong>docker exec -it c2891d477edf /bin/sh</strong> 命令进入容器，c2891d477edf 为容器 ID</p>\n<pre class=\"prettyprint language-bash\"><code>$ docker exec -it c2891d477edf &#x2F;bin&#x2F;sh\n$ ls # 列出目录列表\nDockerfile  app.js  package-lock.json  package.json\n</code></pre><p>由于我们已经启动了 hello-docker 这个服务，在容器里再次操作 node app.js 就会报端口冲突</p>\n<pre class=\"prettyprint\"><code>$ node app\nevents.js:167\n      throw er; &#x2F;&#x2F; Unhandled &#x27;error&#x27; event\n      ^\n\nError: listen EADDRINUSE :::30010\n</code></pre><p><strong>按下 Ctrl + d （或者输入 exit）退出容器</strong></p>\n<h2>Registry实践</h2>\n<p>Registry 是一个注册服务器，是一个集中存放镜像仓库的地方，这里着重介绍下 Docker Hub，它是官方维护的一个公共仓库，我们的大部分需求也都可从这里下载。</p>\n<h4>注册 Docker 账号</h4>\n<p>在开始之前你需要先去 Docker 官网注册一个账号 <a href=\"https://hub.docker.com/\">https://hub.docker.com/</a> 后续讲解发布镜像需要用到</p>\n<h4>镜像搜索</h4>\n<p>使用 <code>docker search 镜像名称</code> 可以搜索你需要的镜像，搜索结果会根据 STARS 进行排序</p>\n<pre class=\"prettyprint language-bash\"><code>$ docker search nginx\nNAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED\nnginx                             Official build of Nginx.                        11935               [OK]                \njwilder&#x2F;nginx-proxy               Automated Nginx reverse proxy for docker con…   1651                                    [OK]\nricharvey&#x2F;nginx-php-fpm           Container running Nginx + PHP-FPM capable of…   740                                     [OK]\n...\n</code></pre><h4>镜像拉取</h4>\n<p>搜索到需要的镜像后执行 docker pull 命令拉取镜像</p>\n<pre class=\"prettyprint\"><code>$ docker pull nginx\n</code></pre><h4>发布镜像实现共享</h4>\n<ol>\n<li>登陆 Docker，已登陆的可以忽略这一步</li>\n</ol>\n<pre class=\"prettyprint\"><code>$ docker login\n</code></pre><ol>\n<li>为本地镜像打标签，tag 不写默认为 latest</li>\n</ol>\n<pre class=\"prettyprint language-bash\"><code># docker image tag [imageName] [username]&#x2F;[repository]:[tag]\n$ docker image tag hello-docker mayjun&#x2F;hello-docker\n</code></pre><ol>\n<li>发布镜像文件</li>\n</ol>\n<pre class=\"prettyprint language-bash\"><code># docker image push [username]&#x2F;[repository]:[tag]\n$ docker image push mayjun&#x2F;hello-docker\n</code></pre><p>镜像发布成功之后，在自己的个人用户下也可以看到镜像信息</p>\n<p><img src=\"//img.mukewang.com/5d8b48c600010efc18940548.png\" alt=\"图片描述\"></p>\n<p>如果你想在别的机器上也使用这个镜像，直接 docker pull 拉取即可，实现镜像的共享。</p>\n<h2>DockerCompose实践</h2>\n<p>Compose 是 Docker 官方开源的一个项目，可以管理多个 Docker 容器组成一个应用，例如 Web 服务，除了服务本身还有数据库、Redis、Nginx 等一系列相关联服务需要安装。</p>\n<p>有个 Compose 的支持，我们只需要定义一个 YAML 格式的配置文件（<code>docker-compose.yml</code>），来编写一个项目所需要的多个容器配置及调用关系，通过简单的命令即可同时开始或者关闭这些容器。</p>\n<h4>二进制安装</h4>\n<p><a href=\"https://github.com/docker/compose/releases\">https://github.com/docker/compose/releases</a></p>\n<pre class=\"prettyprint language-bash\"><code># compose 下载之后通过管道的方式输入至 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose\n# uname -s 查找是什么系统，例如：Linux\n# uname -m 查找是什么版本，例如：x86_64\n$ curl -L https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.25.0-rc2&#x2F;docker-compose-&#96;uname -s&#96;-&#96;uname -m&#96; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose\n\n# 把这个文件变成可执行的\n$ chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose\n</code></pre><p>查看安装是否成功</p>\n<pre class=\"prettyprint\"><code>$ docker-compose --version \ndocker-compose version 1.25.0-rc2, build 661ac20e\n</code></pre><h4>Docker Compose 搭建 WordPress 个人博客</h4>\n<blockquote>\n<p>WordPress 是一个免费开源的个人博客系统，使用的也是比较多的，并且也有 Docker 镜像，使用 Docker 部署还是非常简单的。</p>\n</blockquote>\n<p>在 /usr/src/wordpress 目录下，建立 docker-compose.yml 配置文件，写入如下内容：</p>\n<pre class=\"prettyprint language-yml\"><code>mysql:\n    image: mysql:5.7\n    environment:\n     - MYSQL_ROOT_PASSWORD=123456\n     - MYSQL_DATABASE=wordpress\nweb:\n    image: wordpress\n    links:\n     - mysql\n    environment:\n     - WORDPRESS_DB_PASSWORD=123456\n    ports:\n     - &quot;192.168.6.128:8080:80&quot;\n    working_dir: &#x2F;var&#x2F;www&#x2F;html\n    volumes:\n     - wordpress:&#x2F;var&#x2F;www&#x2F;html\n</code></pre><p>启动容器，浏览器输入 <a href=\"http://192.168.6.128:8080\">http://192.168.6.128:8080</a> 即可看到效果，可以亲自实践下</p>\n<pre class=\"prettyprint language-bash\"><code># -d 参数表示后台启动\n$ docker-compose up -d \n</code></pre><p>关闭容器，执行以下命令需要在 docker-compose.yml 配置文件同级目录下</p>\n<pre class=\"prettyprint\"><code>$ docker-compose stop\n</code></pre><p>本文是作者 “五月君” 在实践 Docker 过程中的一些知识总结，刚开始也是从零开始的，如果你想学习 Docker 不知道该如何入手，可以参考本文，后续还会有 Docker 在应用程序中的实践分享，感兴趣的可以关注公众号 “Nodejs技术栈” Github: <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap\">https://github.com/Q-Angelo/Nodejs-Roadmap </a> 获取最新消息</p>\n</div>","title":"一文零基础教你学会 Docker 入门到实践","last_reply_at":"2019-09-26T01:01:43.535Z","good":false,"top":false,"reply_count":0,"visit_count":192,"create_at":"2019-09-26T01:01:43.535Z","author":{"loginname":"Q-Angelo","avatar_url":"https://avatars0.githubusercontent.com/u/17956058?v=4&s=120"}},{"id":"5d88948853c75a4136b4ce3d","author_id":"5d8892cf53c75a4136b4ce36","tab":"ask","content":"<div class=\"markdown-text\"><p>以前用sequelize的时候只要设置initialAutoIncrement就可以，现在重构项目用typeorm不知道该如何设置了</p>\n</div>","title":"有用nest和typeorm开发项目的嘛？typeorm怎么设置主键自增的起始值？","last_reply_at":"2019-09-25T13:46:30.486Z","good":false,"top":false,"reply_count":5,"visit_count":422,"create_at":"2019-09-23T09:46:48.118Z","author":{"loginname":"472647301","avatar_url":"https://avatars2.githubusercontent.com/u/26315702?v=4&s=120"}},{"id":"5d8b1207e86cfb0d2a645a49","author_id":"59b7a76ee483de126798458e","tab":"ask","content":"<div class=\"markdown-text\"><p>在用egg集成rabbitmq的时候，我希望使用egg自带的Subscription抽象来实现。首先我在agent进程里面创建链接和信道。\n在agent.js里用如下代码创建链接和信道。并且消费队列。</p>\n<pre class=\"prettyprint language- js\"><code>module.exports = agent =&gt; {\n    amqp(agent);\n    class AMQPScheduleStrategy extends agent.ScheduleStrategy {\n        async start() {\n            &#x2F;&#x2F; const channel = await this.agent.amqp.channel;\n            const client = await amqplib.connect(&#x27;amqp:&#x2F;&#x2F;admin:adminglzt@192.168.1.115&#x27;);\n            const channel = await client.createChannel();\n            channel.assertQueue(this.schedule.queue);\n            channel.consume(this.schedule.queue, (msg) =&gt; {\n                &#x2F;&#x2F; this.agent.amqp.channel.ack(msg);\n                this.sendOne(msg);\n            });\n            &#x2F;&#x2F; channel.close();\n        }\n    }\n    agent.schedule.use(&#x27;amqp&#x27;, AMQPScheduleStrategy);\n};\n</code></pre><p>有一个致命的问题就是在worker进程里面需要对消息进行确认，那么这个确认需要<code>channel</code>实例，但是这个对象是没办法传递到worker进程里面的</p>\n</div>","title":"egg集成消息队列遇到的问题","last_reply_at":"2019-09-25T10:43:18.979Z","good":false,"top":false,"reply_count":6,"visit_count":332,"create_at":"2019-09-25T07:06:47.255Z","author":{"loginname":"acodercat","avatar_url":"https://avatars3.githubusercontent.com/u/16076835?v=4&s=120"}},{"id":"5b03bb29000332b81cf821a1","author_id":"5acdfae7464b1bfa6b425058","tab":"ask","content":"<div class=\"markdown-text\"><p>才开始学习使用nodejs，接到一个做第三方的需求</p>\n<p>参照：<a href=\"https://github.com/iamshaunjp/oauth-playlist/tree/lesson-10\">https://github.com/iamshaunjp/oauth-playlist/tree/lesson-10</a>\n进行的实现，相应的clientid，clientsecret已经换成自己的了，但是一跑起来就报这个错\n国内用的shadowsocks翻的墙\n1.google了很久，都没得到解决，有几个方案认为是http代理的问题，提的pac这类的，这个不懂，希望有人能帮助解答一下。\n2.目前网站是http的协议，后面测试facebook要强制https，这个也没解决</p>\n</div>","title":"现金酬谢！！！紧急求助  用passport.js 实现第三方登录时遇到：InternalOAuthError: Failed to obtain access token","last_reply_at":"2019-09-25T06:57:35.116Z","good":false,"top":false,"reply_count":4,"visit_count":1767,"create_at":"2018-05-22T06:39:37.425Z","author":{"loginname":"ZiNai","avatar_url":"https://avatars1.githubusercontent.com/u/18731079?v=4&s=120"}},{"id":"5d8041d653c75a4136b4af6c","author_id":"5d521b5e12a01945444162c2","tab":"ask","content":"<div class=\"markdown-text\"><h4>一、背景</h4>\n<ol>\n<li>用户可以发布文章，可以通过企业认证来绑定企业，可以解绑企业。</li>\n<li>当账号绑定企业后就以<strong>企业身份</strong>发布 (文章关联<code>company_id</code>)；解绑后就以<strong>个人身份</strong>发布 (文章关联<code>person_id</code>)。</li>\n<li>只有个人 ( <code>person</code> ) 才有账号，也就是说只能用个人账户登录。</li>\n</ol>\n<h4>二、问题</h4>\n<p>请问用户表和文章表怎么设计？</p>\n<h4>三、我的方案</h4>\n<p><code>person</code> 表保存个人信息和用户名、密码信息，<code>company</code>表的数据在企业认证时生成并把 <code>company_id</code> 填入 <code>person</code>表：</p>\n<pre class=\"prettyprint language-sql\"><code>CREATE TABLE &#96;person&#96; (\n  &#96;person_id&#96; int unsigned NOT NULL AUTO_INCREMENT,\n  &#96;company_id&#96; int unsigned DEFAULT NULL COMMENT &#x27;企业认证id&#x27;,\n  &#96;username&#96; varchar(255) NOT NULL\n  &#96;password&#96; varchar(255) NOT NULL\n  PRIMARY KEY (&#96;person_id&#96;),\n) \n\nCREATE TABLE &#96;company&#96; (\n  &#96;company_id&#96; int unsigned NOT NULL AUTO_INCREMENT  COMMENT &#x27;企业认证id&#x27;,\n  PRIMARY KEY (&#96;company_id&#96;),\n) \n\nCREATE TABLE &#96;article&#96; (\n  &#96;article_id&#96; int unsigned NOT NULL AUTO_INCREMENT,\n  &#96;user_id&#96; int unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;person_id 或者 company_id&#x27;,\n  &#96;user_type&#96; varchar(20) NOT NULL COMMENT &#x27;person 或者 company&#x27;\n  PRIMARY KEY (&#96;article_id&#96;),\n)  \n</code></pre><p><strong>但问题是</strong>：如果按如上方式设计 person、company 表的话，类似 article 的很多表就需要保存 <code>user_type</code>，比较麻烦，有更好的设计吗？</p>\n</div>","title":"个人可以绑定/解绑一个企业，数据库如何设计？","last_reply_at":"2019-09-25T06:25:58.456Z","good":false,"top":false,"reply_count":15,"visit_count":2168,"create_at":"2019-09-17T02:15:50.162Z","author":{"loginname":"xuxu7","avatar_url":"https://avatars1.githubusercontent.com/u/8274162?v=4&s=120"}},{"id":"5d84e16b95464514f7ed8aab","author_id":"5d649b3ddcd8e81121a61491","tab":"ask","content":"<div class=\"markdown-text\"><p>目前有多个spa，分别对接了sso系统，被分配了不同的appId。</p>\n<p>期望没有权限的时候统一跳转登录页，但是可能页面都不会发出ajax请求，所以不应该在每个子系统分别根据请求的code做前端的跳转。\n所以最好是有一个统一的网关出口，所以用户访问的地址都通过这个网关透出，在网关这一层做权限的验证。</p>\n<p>最好是能支持配置对外的地址、实际服务的地址和跳转登录页的地址，有类似现成的东西？</p>\n</div>","title":"有多个spa，期望做一个统一的类似网关的东西，做权限的验证，有什么比较合适的框架或者方案？","last_reply_at":"2019-09-25T02:52:03.372Z","good":false,"top":false,"reply_count":5,"visit_count":1284,"create_at":"2019-09-20T14:25:47.938Z","author":{"loginname":"huyansheng3","avatar_url":"https://avatars2.githubusercontent.com/u/11534583?v=4&s=120"}},{"id":"5c1c9ab676c4964062a1c3e1","author_id":"5372465f3c72496d41009adc","tab":"share","content":"<div class=\"markdown-text\"><p>《Node.js开发实战》原书排名并发编程类榜首。有读者坐火车十小时一口气读完，欲罢不能！好不好，试读就知道。</p>\n<p><strong>62页试读下载</strong>：<a href=\"https://pan.baidu.com/s/1x3c35AmJV4rcEj_W3A1WGg\">https://pan.baidu.com/s/1x3c35AmJV4rcEj_W3A1WGg</a></p>\n<p><strong>读者热评</strong>：</p>\n<ul>\n<li>看的欲罢不能啊，火车上来回十个小时，把整体内容浏览了一遍，然后现在精读到第二张，发现学到了好多东西，好书。\n——京东读者 小***土</li>\n</ul>\n<ul>\n<li>粗略的看了一遍,准备细读一下,很多地方给详细讲了es6的新特性,包括let、const、还有class和promise,还讲解了async和await,反正不太需要有es6基础也能看得懂,不过都要2019了,其实这些应该是前端必备技能了吧.书写的很好,循序渐进,感觉前端在没搞懂node之前,其实并不需要去学py啊php啊之类的,语言毕竟只是工具,利用工具做事情的理念是想通的.(最后这句说给我自己的)\n——豆瓣读者 陈小土</li>\n</ul>\n<ul>\n<li>很不错的一本关于node的实战书！\n——京东读者 f***8</li>\n</ul>\n<ul>\n<li>内容由浅入深，引人入胜。\n——京东读者 d***t</li>\n</ul>\n<p><strong>京东有售</strong>：<a href=\"https://item.jd.com/12460185.html\">https://item.jd.com/12460185.html</a></p>\n<p><img src=\"//static.cnodejs.org/Finp2H7di-Equ_yMWsjJY6hxYGkh\" alt=\"WechatIMG148 copy.jpg\"></p>\n</div>","title":"新书《Node.js开发实战》抢鲜试读","last_reply_at":"2019-09-25T02:49:43.041Z","good":false,"top":false,"reply_count":28,"visit_count":10731,"create_at":"2018-12-21T07:48:06.079Z","author":{"loginname":"meikidd","avatar_url":"https://avatars0.githubusercontent.com/u/376338?v=4&s=120"}},{"id":"5ce3bbbfe57aac76fed2ca9b","author_id":"5ce3bafde57aac76fed2ca85","tab":"share","content":"<div class=\"markdown-text\"><p>VUE怎么学习？</p>\n</div>","title":"VUE怎么学习？","last_reply_at":"2019-09-24T14:39:17.245Z","good":false,"top":false,"reply_count":7,"visit_count":1926,"create_at":"2019-05-21T08:50:07.795Z","author":{"loginname":"luobo007","avatar_url":"https://avatars3.githubusercontent.com/u/7908554?v=4&s=120"}},{"id":"5cef9f6f4036f24194cf805c","author_id":"5c875af8acb681372d41753b","tab":"share","content":"<div class=\"markdown-text\"><p>Dart教程在线试听地址： <a href=\"https://www.bilibili.com/video/av52490605\">https://www.bilibili.com/video/av52490605</a></p>\n<p>Flutter教程在线试听地址： <a href=\"https://www.bilibili.com/video/av52490605/?p=15\">https://www.bilibili.com/video/av52490605/?p=15</a></p>\n<p><strong>2019年5月新出Dart Flutter入门实战视频教程网盘下载地址：</strong></p>\n<p><a href=\"https://pan.baidu.com/s/1WCobyt_1Oy4KDUmnSsCpiw\">https://pan.baidu.com/s/1WCobyt_1Oy4KDUmnSsCpiw</a>  提取码：xwpq</p>\n</div>","title":"2019年5月录制的Dart Flutter入门实战系列视频教程-网盘免费分享","last_reply_at":"2019-09-24T14:23:42.052Z","good":false,"top":false,"reply_count":14,"visit_count":6519,"create_at":"2019-05-30T09:16:31.065Z","author":{"loginname":"youmenglinzi","avatar_url":"https://avatars0.githubusercontent.com/u/48469369?v=4&s=120"}},{"id":"5ceabebb4036f24194cf6b6d","author_id":"58f837a3bbaf2f3f569be082","tab":"share","content":"<div class=\"markdown-text\"><h1>今日份的X</h1>\n<p>Github：<a href=\"https://github.com/shuiRong/TodayX\">https://github.com/shuiRong/TodayX</a>  （今日份的X）</p>\n<blockquote>\n<p>这是一个<code>Flutter</code>写的<strong>一个无聊的App</strong></p>\n<p><strong>每天推荐一个不同的：图片、诗歌、名言、音乐、乐评、高等数学、两种配色、化学方程式、Github Repo、知乎问题。</strong></p>\n<p>（P.S. 除图片来自Bing首页，每天仅有一张外，其他页面支持下拉刷新来更新内容）</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/shuiRong/TodayX/releases\">下载APK</a></strong></p>\n<p><img src=\"https://i.imgur.com/tizNA8s.jpg\" alt=\"预览\"></p>\n<blockquote>\n<p><strong>Flutter初试感受</strong>：去玩<code>Swift</code>了 :p</p>\n</blockquote>\n</div>","title":"试玩Flutter：写了个无聊的App（附Flutter感受）","last_reply_at":"2019-09-24T13:42:56.180Z","good":false,"top":false,"reply_count":11,"visit_count":3685,"create_at":"2019-05-26T16:28:43.686Z","author":{"loginname":"shuiRong","avatar_url":"https://avatars1.githubusercontent.com/u/16076993?v=4&s=120"}},{"id":"5d784a29a7474a231a58ad80","author_id":"5becd64fbe1b120abac597f4","tab":"share","content":"<div class=\"markdown-text\"><p><strong>Egg.js</strong>是《阿里旗下产品》基于Node.js 和 Koa的一个Nodejs的企业级应用开发框架，它可以帮助开发团队及开发人员降低开发和维护成本。它类似于 Ruby 的 Ruby On Rails、Python 的 Django、Php 的 Laravel，是一款值得深入研究的框架。</p>\n<p><strong>大地老师Egg.js仿小米商城项目已更新130讲</strong>，仿小米商城项目不是一个简单的管理系统，完全的仿小米商城项目实战，RBAC权限管理、商品管理、用户管理、导航管理、文章管理、订单管理、支付宝支付、微信支付…</p>\n<p><strong>完整目录访问：</strong> <a href=\"https://www.itying.com/goods-941.html\">https://www.itying.com/goods-941.html</a></p>\n<p><strong>eggjs 10讲免费入门教程访问：</strong> <a href=\"http://bbs.itying.com/topic/5bcd6da2dc95510a3063e10d\">http://bbs.itying.com/topic/5bcd6da2dc95510a3063e10d</a></p>\n<p><strong>Egg.js基础教程包括:</strong>  Egg.js的基本使用、Egg.js中的路由 、Egg.js中的控制器、Egg.js中的服务、Egg.js中的Model、Egg.js中的Config 以及插件、Egg.js中的view模块引擎、Egg.js中的中间件 、Egg.js扩展 Extend、Egg.js CSRF 的防范、Egg Cookie、Egg Session、Egg.js 定时任务、Mongodb4.x、Mongoose、Egg.js+Mongoose、Egg.js中Mysql的使用、Sequelize ORM框架的使用等…</p>\n<p><strong>Egg.js仿小米商城项目包括:</strong>  Egg.js基础的应用 、egg-view多模板引擎、Egg中Md5的使用、Egg生成验证码、数据库ER图、用户RBAC权限管理（不同角色用户登录后台显示不同菜单，涉及角色、权限、用户的增删改查以及关联）、公共的Ajax改变状态、Ajax双击更改数量、Ajax双击排序、图片上传、生成缩略图、wysiwyg-editor的使用、商品管理中动态生成商品属性表单、批量上传图片插件、redis 的使用、Egg.js发送短信、Pc端微信支付、Pc端支付宝支付、Elasticsearch全文搜索引擎、Socket.io机器人 、Socket.io多人聊天室、Socket.io群聊、前后端分离 RESTful API Api接口、购买域名 服务器、域名备案、nginx负载均衡、SSL证书Https配置等等…</p>\n<p><img src=\"//static.cnodejs.org/Fp8erhbPkGZrsYFsd-gxn2z4Gssb\" alt=\"1.png\"></p>\n<p><img src=\"//static.cnodejs.org/FhCAuCKVwbQnTCJWtkGKv6ZR8toN\" alt=\"2.png\"></p>\n<p><img src=\"//static.cnodejs.org/FpnFP2WY9YBnPygNGT7y977hnQ5O\" alt=\"3.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fu_lhZW2WdVtE05rGRqtVWT42G9Q\" alt=\"4.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fq7M2FL4nsEbXvp_xOmW2RFZZn1m\" alt=\"5.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fk7rfDAEAhgo5IUiOH7phlC7MWpv\" alt=\"6.png\"></p>\n<p><img src=\"//static.cnodejs.org/FosTPjBgGJCq_UT87elcbwgUic6a\" alt=\"7.png\"></p>\n<p><img src=\"//static.cnodejs.org/FuKpyqW5SX_dzDkP_tUujD-OvkwJ\" alt=\"8.png\"></p>\n<p><img src=\"//static.cnodejs.org/FsphTYau58anhXz2x_SgCxbexsMT\" alt=\"9.png\"></p>\n<p><img src=\"//static.cnodejs.org/FofjI9KOV0_ZQwg-VzfYps51KsEk\" alt=\"10.png\"></p>\n</div>","title":"Egg.js仿小米商城项目已更新130讲-RBAC权限管理、Mongoose、Sequelize、Elasticsearch、Socket.io、redis、Graphql你想要的都有讲","last_reply_at":"2019-09-24T12:38:01.120Z","good":false,"top":false,"reply_count":9,"visit_count":3700,"create_at":"2019-09-11T01:13:13.414Z","author":{"loginname":"magege666","avatar_url":"https://avatars1.githubusercontent.com/u/45024820?v=4&s=120"}},{"id":"5d83398095464514f7ed8339","author_id":"5d83395c95464514f7ed8333","tab":"share","content":"<div class=\"markdown-text\"><h3>什么是 Daze.js</h3>\n<p>Daze.js 是一款 Node.js 服务端 Web 开发框架，底层基于 IOC 容器模式实现，使用装饰器进行依赖注入，结合 AOP 模式编程</p>\n<blockquote>\n<p>由于使用装饰器进行依赖注入，所以依赖 Babel 生态</p>\n</blockquote>\n<h3>特性</h3>\n<ul>\n<li>基于 IOC 容器模式设计，模块深度解耦</li>\n<li>支持 AOP 编程，对业务逻辑的各个部分进行隔离</li>\n<li>路由去中心化，通过注入实现路由定义，提升阅读质量</li>\n<li>内置多种组件类型，应对复杂场景</li>\n<li>支持自定义提供者，具备高扩展能力</li>\n<li>自动加载组件自动分类注册，自动化体验极佳</li>\n<li>更多…</li>\n</ul>\n<h3>目标</h3>\n<p>做最好的开发体验</p>\n<h3>Example</h3>\n<pre class=\"prettyprint language-js\"><code>const { Controller, Route, Http } = require(&#x27;@dazejs&#x2F;framework&#x27;)\n\n[@Route](&#x2F;user&#x2F;Route)(&#x27;&#x2F;superman&#x27;)\nclass Superman extends Controller {\n  @Http.Get(&#x27;&#x2F;create&#x27;)\n  create() {\n    return this.response().Created()\n  }\n}\n</code></pre><p>上面的示例是一个控制器的代码，使用 <a href=\"/user/Route\">@Route</a> 装饰器表示这是一个路由控制器，并且路由前缀为 <code>/superman</code>, 控制器继承了基础控制器 <code>Controller</code>, 表示这是一个控制器模块，使用 Http.Get 装饰器开放 <code>/superman/create</code> 访问路径，我们可以使用 <code>GET /superman/create</code> 访问该资源，使用 <code>this.response().Created()</code> 创建状态码为 <code>201 Created</code> 的响应</p>\n<h3>目录结构</h3>\n<pre class=\"prettyprint language-txt\"><code>.\n├── dist                        &#x2F;&#x2F; 打包目标目录\n├── logs                        &#x2F;&#x2F; 日志目录\n├── package.json\n├── public                      &#x2F;&#x2F; 静态资源目录\n├── src                         &#x2F;&#x2F; 源码目录\n│   ├── app                     &#x2F;&#x2F; 应用目录\n│   │   ├── controller          &#x2F;&#x2F; 控制器目录（推荐）\n│   │   ├── middleware          &#x2F;&#x2F; 中间件目录（推荐）\n│   │   ├── service             &#x2F;&#x2F; 服务类目录（推荐）\n│   │   ├── resource            &#x2F;&#x2F; API 资源目录（推荐）\n│   │   ├── component           &#x2F;&#x2F; 通用组件目录（推荐）\n│   │   ├── validator           &#x2F;&#x2F; 验证器目录（推荐）\n│   ├── config                  &#x2F;&#x2F; 应用配置目录\n│   └── index.js                &#x2F;&#x2F; 应用入口文件\n└── views                       &#x2F;&#x2F; 视图文件目录\n</code></pre><p><code>src/app</code> 下的目录结构可自行定义</p>\n<h3>控制器</h3>\n<h4>路由参数</h4>\n<p>路由参数框架已经通过控制器方法自动注入, 我们可以通过定义路由参数的顺序来获取</p>\n<pre class=\"prettyprint language-js\"><code>const { Controller, Route, Http } = require(&#x27;@dazejs&#x2F;framework&#x27;)\n\n[@Route](&#x2F;user&#x2F;Route)(&#x27;&#x2F;superman&#x27;)\nclass Superman extends Controller {\n  @Http.Get(&#x27;&#x2F;create&#x2F;:name&#x2F;:driver&#x27;)\n  create(name, driver) {\n   return { name, driver }\n  }\n}\n</code></pre><p>当我们访问 <code>/superman/create/xiaoming/lily</code>, 我们就可以通过参数直接获取 <code>name</code>和 <code>driver</code></p>\n<h4>请求</h4>\n<p>控制器中，可以直接通过控制器实例获取请求实例</p>\n<pre class=\"prettyprint language-js\"><code>const { Controller, Route, Http } = require(&#x27;@dazejs&#x2F;framework&#x27;)\n\n[@Route](&#x2F;user&#x2F;Route)(&#x27;&#x2F;superman&#x27;)\nclass Superman extends Controller {\n  @Http.Get(&#x27;&#x2F;create&#x27;)\n  create() {\n    const name = this.request.getParam(&#x27;name&#x27;)\n    return name\n  }\n}\n</code></pre><p>在上述例子中，如果我们访问 <code>/superman/create?name=xxx</code>, 我们就可以通过 <code>this.request.getParam('name')</code> 获取到 name 的值：xxx</p>\n<h4>响应</h4>\n<p>大部分情况我们只需要在控制器直接 <code>return</code> 数据即可返回结果，框架另外还支持返回资源实例，视图实例，响应实例等</p>\n<p>这里我们先介绍下响应实例，可以直接通过控制器方法属性 <code>this.response(data, code, headers)</code> 创建响应实例：</p>\n<pre class=\"prettyprint language-js\"><code>const { Controller, Route, Http } = require(&#x27;@dazejs&#x2F;framework&#x27;)\n\n[@Route](&#x2F;user&#x2F;Route)(&#x27;&#x2F;superman&#x27;)\nclass Superman extends Controller {\n  @Http.Get(&#x27;&#x2F;create&#x27;)\n  create() {\n    return this.response(&#x27;data&#x27;, 200, {\n      &#x27;conetent-type&#x27;: &#x27;application&#x2F;json&#x27;\n    })\n  }\n}\n</code></pre><p>响应实例还提供了更多有用的方法，具体可以查看官方文档（文章最后会有）</p>\n<h3>更多功能</h3>\n<p><code>Daze.js</code> 目前刚发布 1.0 版本，功能已经很多，一篇文章介绍不完，大家可以期待后续的文章或者关注项目了解更多，还有更多的功能迭代计划</p>\n<p>后续还有更多深入介绍使用方法和原理的文章</p>\n<p>这仅仅是开源的第一步</p>\n<h3>功能计划</h3>\n<ul>\n<li>websocket</li>\n<li>granphQL</li>\n<li>Dubbo</li>\n<li>DB</li>\n<li>ORM</li>\n<li>更多 …</li>\n</ul>\n<p>大家有更多的想法可以去 issue 提出： <a href=\"https://github.com/dazejs/daze/issues/1\">https://github.com/dazejs/daze/issues/1</a></p>\n<h3>传送门：</h3>\n<p>官网：<a href=\"https://dazejs.org\">https://dazejs.org</a></p>\n<p>项目地址: [<a href=\"https://github.com/dazejs/daze\">https://github.com/dazejs/daze</a>](</p>\n</div>","title":"使用 Daze.js 开发 Node 应用 - 介绍篇","last_reply_at":"2019-09-24T12:05:53.248Z","good":false,"top":false,"reply_count":3,"visit_count":1607,"create_at":"2019-09-19T08:17:04.487Z","author":{"loginname":"czewail","avatar_url":"https://avatars1.githubusercontent.com/u/14213748?v=4&s=120"}},{"id":"5d89ee3ee86cfb0d2a645785","author_id":"5d89eba95cbcc579bb9ea836","tab":"ask","content":"<div class=\"markdown-text\"><p>[<img src=\"https://s2.ax1x.com/2019/09/24/uArFsO.jpg\" alt=\"uArFsO.jpg\">]\n[<img src=\"https://s2.ax1x.com/2019/09/24/uAriQK.jpg\" alt=\"uAriQK.jpg\">]</p>\n<p>我如果把代码更改一下,改成这样: <code>app.use('/', proxy({target: 'https://api.douban.com', changeOrigin: true}))</code>;然后请求代理地址<code>http://localhost:4000/v2/music/search?q=周杰伦</code>就没有任何毛病,数据可以正常返回, 我现在很纳闷,代码都是根据npm上面写的,百度了好多也是这样的,为啥我的不行呢?\n修改后的请求,是不是我太笨了,脑瓜子哇哇的…\n<img src=\"https://s2.ax1x.com/2019/09/24/uArWSx.jpg\" alt=\"uArWSx.jpg\"></p>\n</div>","title":"关于express代理http-proxy-middleware中间件的问题","last_reply_at":"2019-09-24T12:00:37.093Z","good":false,"top":false,"reply_count":2,"visit_count":319,"create_at":"2019-09-24T10:21:50.395Z","author":{"loginname":"ztao0916","avatar_url":"https://avatars1.githubusercontent.com/u/37857018?v=4&s=120"}},{"id":"5d89e1004f109e79ef5ff38b","author_id":"5d80a56d53c75a4136b4b188","tab":"ask","content":"<div class=\"markdown-text\"><p>本文推荐中国能用的VPN翻墙软件，顺便介绍代理翻墙方法：SSR搭建等。推荐中国用户首选ExpressVPN翻墙，用SSR作为备份。</p>\n<hr>\n<h1><strong>在中国使用翻墙软件需知</strong></h1>\n<hr>\n<h2>墙并没有那么高</h2>\n<hr>\n<p>国内网民觉得墙很高，其实每年除了少数几个时段外，用VPN或SSR翻墙并不难，虽然也谈不上特别容易，毕竟买VPN或者搭建SSR都要费时间费钱。很多人觉得翻墙难，大概就是几类原因。首先就是不想花钱，整天找免费的东西，免费VPN，免费SSR节点分享，免费的东西很多，也有一些确实能用的，但几乎所有免费服务最终都是很难或不可用的。绝大多数免费的VPN或者SSR节点，公网上随便一搜就搜得到，你能看到墙也能看到，多数都很短命。其次就是懂点技术的网民的那一点偏执，觉得自己架设的东西最好，不相信第三方更专业的付费服务。国内很多人用香港、日本等地的主机来搭SSR，有不少确实是稳定地用着，但也有不少IP被封，不得不折腾换IP、换主机的。所以它们觉得翻墙很难。</p>\n<p>其实翻墙只需要准备一两个工具就行了，像我自己就常备<a href=\"https://dwz.cn/XwNVwZQb\">ExpressVPN</a>和ssr，用了好几年了，除了少数敏感时期两个都挂掉以外，其余时间基本可以保证100%翻墙成功率，绝大多数时候我用ExpressVPN，虽然每天都会有几次断线重连，但极少碰到连不上的情况，最糟糕的情况也就是换个节点连一下，香港的如果连起来慢了，就换洛杉矶的，洛杉矶的慢了，就换日本、新加坡的等等。ssr用来作备份，因为价格便宜，但没有ExpressVPN强大，有了这两个软件，我从来没担心过无法翻墙的问题。剩下的，就是保持两个工具的更新，这是同时安装两个翻墙软件的好处，主要是为了当一个软件版本过期无法连接的时候，另一个还能连上让它更新。</p>\n<hr>\n<h2>翻墙是为了不影响学习与工作，不是去诋毁中国和中国人</h2>\n<hr>\n<p>你要明白世界的媒体是受西方控制的，舆论战里众多西方媒体是进攻的一方，而非西方阵营的国家只能选择防守，我们不说墙的存在对你我个人是好或不好，方便与不方便，如果说这个，当大概是不好也不方便，但也得明白防火墙存在在政治与国家安全上的‘合理性’。比如Facebook被封的原因：</p>\n<blockquote>\n<p>由于乌鲁木齐七·五骚乱部分新疆独立运动者使用Facebook为交流平台，引起中国大陆封锁Facebook至今。</p>\n</blockquote>\n<p>绝大多数西方媒体都带有浓烈的意识形态企图，它们绝对不是“公正中立”的，明白这一点的中国人会越来越多。<a href=\"https://user.guancha.cn/main/content?id=29826\">选择性报道，恶意扭曲的例子</a>并不少，甚至一度还有“中国共产党镇压狗”的奇葩新闻，西方媒体说谎作恶，无所不用其极。翻墙绝对不是为了去做西方媒体的喉舌，你只要被绕进去，就很难看到全部的事实了。翻墙是首先是为了不影响个人学习与工作，其次是为了更好地学习和工作，还当然有娱乐：）Googe，Youtube，Facebook，Twitter上都有大量有益的信息可以看。况且前面说了，对个人来说，墙的门槛实际上并没有你想的那么高，墙的存在并不能阻止你获得这些信息。</p>\n<p>不要假设“翻墙后”的必然选择是搞些猎奇反动的事情，翻墙后有很多有趣、有意义的东西可以看。有一些免费翻墙工具背后是美国国会支持的，典型代表是曾经流行的自由门，就有美国国会几百万美金的拨款，自由门绝对不是唯一一款，这种免费VPN会向用户不停推送反动信息，好在几年前被封了。</p>\n<hr>\n<h2><strong>绝不要分发分享自建VPN，SSR机场，脚本等</strong></h2>\n<hr>\n<p>国内有些小朋友看到搭建SSR这么容易，就去建机场，这是典型的作死，可以自行去搜机场主或者站长被请抓的新闻。个人VPN，SSR你自己用，请保持低调。不要到微信、微博这些地方去分发，除非你很想喝茶。分发分享自建VPN，SSR机场是犯法的。 看下面这些事件：</p>\n<p><strong>2019年3月，翻墙技术网站“逗比根据地”站长被起诉：</strong></p>\n<p>“逗比根据地”是一个提供翻墙技术的中文网站。2018年底，该网站创始人孙东洋（网名Toyo Sun）在国内被捕。在被关押5个多月后，孙东洋于2019年3月25日被以“提供侵入计算机系统工具罪”起诉。</p>\n<p><strong>2019年1月，重庆网民因使用VPN受到指控：</strong></p>\n<p>2019年1月，据网络流传的图片显示，重庆市荣昌区公安局对一名使用VPN的网民黄某的家属进行了传唤。</p>\n<p><strong>2019年1月，广东网民因使用VPN被罚款：</strong></p>\n<p>2019年1月，广东一位朱姓网民因为“擅自建立、使用非法定信道进行国际联网”被韶关市公安局警告并罚款1,000元人民币。文件显示：朱某从2018年8月到12月，在自己手机上多次使用翻墙软件蓝灯（Lantern Pro）。这是一次因个人使用VPN被罚的事件。</p>\n<hr>\n<h2>什么才是中国好用的翻墙软件</h2>\n<hr>\n<p>你可能听说过这些关于翻墙工具的名称，例如：VPN、机场、SSR、节点、远程服务器、VPS、科学上网软件、软路由、V2Ray、Shadowsocks、翻墙软件、代理服务器、网页代理、蓝灯、自由门、赛风、浏览器翻墙、翻墙出国、翻墙回国 等等。所有的这些名称，归根结底就一条！那就是通过“远程服务器”作为中继点，将墙外的信息通过这个中继服务器传输给国内你所在的电脑上。这样你就实现了观看墙外信息的需求，也就是俗话说的翻墙。</p>\n<p>要区分他们也很容易。只有两类：第一类是VPN，第二类是翻墙软件。本质区别在于VPN的第一要务是保障使用者的数据传输安全，其次才是能够帮助中国境内用户翻墙（真正的VPN都是国外的，中国没有VPN）。翻墙软件没有其它职能，唯一的任务就是帮助中国境内用户翻墙。我不能说翻墙软件100%都是不安全的，但是因为这种软件没有正规化的运营，游走在中国法律的边缘，很多都是个人或小团队运作，这就很难保障使用者的数据安全了。</p>\n<hr>\n<h1>中国VPN翻墙软件推荐</h1>\n<hr>\n<h2><a href=\"https://dwz.cn/XwNVwZQb\"><strong>ExpressVPN</strong></a> - 最好用的中国VPN</h2>\n<hr>\n<p>如果只能推荐一个<a href=\"https://www.expressvpn.com/de/what-is-vpn\">VPN</a>，那应该是ExpressVPN，它是市场上价格最高的，但稳定性和速度是最好的。</p>\n<p><strong>为什么ExpressVPN是最好用的中国VPN翻墙软件？</strong></p>\n<p>世界上的VPN软件成千上万，愿意为中国用户提供镜像站的一只手数得过来，<a href=\"https://dwz.cn/XwNVwZQb\">ExpressVPN的镜像站</a>对中国用户始终保持着可访问。客户端好用的VPN不少，但提供无需Google Play Store和苹果美国商店即可安装客户端的VPN厂商，恐怕ExpressVPN是仅有的几家之一。</p>\n<p><strong>所以，为什么推荐ExpressVPN？因为它重视中国市场。</strong></p>\n<p><img src=\"//static.cnodejs.org/Flyc55liEmdJkQJA6upa5r_P1GYN\" alt=\"image.png\"></p>\n<p>推荐香港、日本、新加坡、美国节点，提供国内能打开的镜像站，<a href=\"https://dwz.cn/XwNVwZQb\">不翻墙即可购买</a>，真正全终端覆盖，电脑（Windows，MacOS，Linux），手机（安卓，iOS：iPhone，iPad），路由器，游戏主机（PS2，XBox）等，安卓手机无需Google Play也可安装，iOS设备无需访问苹果商店也可安装，同时5台设备，单独配置哪些应用走VPN哪些不走（Split Tunneling） ，30天无条件退款，<a href=\"https://www.vpnnice.com/go/expressvpn/\">买一年送3个月</a>，支持支付宝付款，支持P2P下载，不限流量。\n<strong>ExpressVPN教程（需翻墙看）</strong></p>\n<ul>\n<li><a href=\"https://youtu.be/RL9Im-dj7Ow\">安卓</a></li>\n<li><a href=\"https://youtu.be/9QCSkP5of2M\">mac</a></li>\n<li><a href=\"https://youtu.be/QawZO5LPUCw\">ios</a></li>\n<li><a href=\"https://youtu.be/9GqvZdCj8lU\">Linux</a></li>\n</ul>\n<hr>\n<h3><a href=\"https://dwz.cn/SqBBl4Lm\">VyprVPN</a></h3>\n<hr>\n<p>推荐台湾、韩国，香港、日本、新加坡、美国等地节点，不用翻墙国内可以购买，独家变色龙混淆协议 ，同时5台设备，30天无条件退款，支持支付宝付款，支持P2P下载，不限流量。</p>\n<p>VyprVPN是我确定中国能用的VPN软件，台湾、韩国的节点出奇地快。VyprVPN的价格低于ExpressVPN，对于觉得ExpressVPN太贵的用户，我推荐你用VyprVPN。</p>\n<p>一分钱一分货，VyprVPN的设备支持，可用节点书（对中国用户）没有ExpressVPN强大。</p>\n<hr>\n<h3><a href=\"https://dwz.cn/Cumdp1zv\">NordVPN</a></h3>\n<hr>\n<p>香港，日本，美国节点，同时6台设备，可能要翻墙购买，随时退款。NordVPN很便宜，而且能随时退款。</p>\n<hr>\n<h3><a href=\"https://dwz.cn/rDWp2xAI\">PureVPN</a></h3>\n<hr>\n<p>香港，日本，美国节点，同时5个连接，需要翻墙购买，31天无条件退款。华侨翻墙回国的首选VPN。</p>\n<hr>\n<h1>关于免费VPN</h1>\n<hr>\n<p>有很多VPN提供商，其中许多也提供免费服务。 然而，问题是这些免费程序通常速度较低，可靠性，安全性和支持。 如果您想使用VPN来传输内容，速度和可靠的连接非常重要。</p>\n<p>选择VPN提供商时，安全性也是一个非常重要的因素。 在大多数情况下，免费VPN服务将提供点对点隧道协议（PPTP），这是最容易设置的。 PPTP突出了一些漏洞，这些漏洞可能使这些VPN连接容易受到攻击。 另一方面，付费服务提供各种VPN协议，例如IPsec（互联网协议安全）和L2TP（第2层隧道协议），它们比PPTP更安全。</p>\n<p>另一个重要因素是VPN服务上可用的带宽。 免费服务往往没有资源投资有效的互联网连接，导致连接速度变慢。 另一方面，付费VPN应用程序为客户提供更安全，更快速的连接。</p>\n<p>除安全性和带宽外，供应商有许多服务器是非常重要。 付费VPN服务通常拥有非常多的服务器，这使您的VPN连接快速而强大，这样您就可以在不缓冲问题或丢失连接的情况下传输内容。</p>\n<p>付费服务总是比免费服务有更好的客户服务。 免费服务通常要求您排除故障并修复自己的VPN问题，而付费服务通常提供全天候客户服务。付费VPN还可通过电话提供良好的客户服务，如果您无法在线解决问题，这可能很有用。</p>\n<hr>\n<h1><strong>关于破解VPN</strong></h1>\n<hr>\n<p>不要相信什么破解VPN，根本不能用。因为VPN软件都分客户端和服务器端，破解了客户端又什么用的，服务端算法、服务地址等都会变，所以没什么卵用。</p>\n<p>破解版软件很容易被挂马，带病毒，别说我没提醒你。实在不想花钱的，至少可以用免费版。</p>\n<hr>\n<h1>关于VPN翻墙的稳定性和速度</h1>\n<hr>\n<p>没有100%稳定的VPN，每年特殊时间段（如六月初）的连接质量都不好，容易断线，这不是某个VPN的问题，所有的翻墙软件都会这样，一般到六月中就会完全恢复。</p>\n<p>日常使用，偶尔断线，换服务器重连即可。</p>\n<p>即使是同一个服务，在一天不同时段，或在不同地域访问，服务质量也会不同，如果你带着小飞机全国各地跑，也是一样，这是由当地网络状况决定的。</p>\n<p>网上说的什么某个VPN软件看油管一年365天一天24小时都能1080P，是不可信的。但ExpressVPN这样的，可以做到一年99%的时间内，都可以流畅观看720P的视频。</p>\n<hr>\n<h1>中国最快的VPN节点</h1>\n<hr>\n<p>香港到大陆的ping值是最低的（小于100ms），如果软件提供，应该是最优质的翻墙节点。日本（100ms至200ms之间），美国（200ms以上），新加坡（200ms以上），都是连接稳定速度较好的VPN节点。</p>\n<p>提供台湾节点和韩国节点的VPN不多，我自己的感觉，连上的时候很快，但经常连不上，不知道什么原因。</p>\n<hr>\n<h1>总结一下</h1>\n<hr>\n<ul>\n<li>电脑翻墙：VPN，蓝灯，SSR都是可行的方案。对小白来说，VPN的客户端省去配置的麻烦，花钱省时间。如果懂技术，SSR也不错。*</li>\n<li>安卓翻墙：VPN不错，看个人，SSR也行，不过个人觉得SSR手机客户端没有桌面客户端好用。</li>\n<li>iOS翻墙：VPN是最好的方案，SSR也行，但可能买付费的客户端会比较好，免费的都不是很好用。</li>\n<li>路由器翻墙：VPN软件提供的可自动安装工具应该是最方便的选择。</li>\n<li>智能电视：取决于电视操作系统。</li>\n<li>游戏主机：VPN是最好的选择。</li>\n</ul>\n<hr>\n<h1>附：VPN术语解释</h1>\n<hr>\n<h2>隐藏IP地址</h2>\n<hr>\n<p>连上VPN后，所有流量都走VPN软件提供的线路，相当于在本机与VPN远程服务器之间建立起一条秘密通道，入口是本机端口，出口是服务器某个端口，对被访问的网站等服务来说，直接访问者是远程服务器，从而达到隐藏本机IP地址的目的。</p>\n<p>隐藏IP地址即是保护隐私的需要，在需要访问有IP限制的服务时（如Netflix只允许部分国家的IP访问）也非常有用。</p>\n<hr>\n<h2><a href=\"https://en.wikipedia.org/wiki/DNS_leak\">DNS泄漏保护</a></h2>\n<hr>\n<p>上面说了VPN会在本机和远程服务器间开辟隧道，让流量同行，通常指的流量是数据流量，比如下载网页，DNS泄露保护，是将本机对网站域名的访问请求（转化为IP）也走VPN通道的保护机制，它最大限度地保护用户隐私，否则网络中间商就可以侦测到你的机器都访问了哪些域名，有了DNS泄露保护，网络中间商就无法嗅探到你的网站访问记录了。</p>\n<hr>\n<h2>混淆协议</h2>\n<hr>\n<p>单纯的VPN协议如OpenVPN虽然也有加密算法，但在GFW防火墙面前也不堪一击。所以好的VPN软件都会单独开发混淆协议。混淆的作用就是把VPN流量尽可能搞得不像VPN加密流量，骗过墙的侦测算法，更有效地帮助用户翻墙。</p>\n<p>ExpressVPN，VyprVPN等软件都开发了商用混淆协议，这是这类软件比普通VPN更稳定的原因。</p>\n<hr>\n<h2>##Split Tunneling</h2>\n<p>当你连上VPN软件后，默认所有流量都走VPN连接，这会导致访问中国国内网站（如知乎、百度、微博、优酷等）变慢。Split Tunneling允许你指定那些应用程序不走VPN线路，如在<a href=\"https://dwz.cn/XwNVwZQb\">ExpressVPN</a>内，你可以配置Firefox浏览器不走VPN，Chrome浏览器走VPN，这样访问国内站点时用Firefox，访问国外站点时用Chrome，国内外网站访问速度都能达到最优。</p>\n<p>链接：</p>\n<ul>\n<li>\n<p><a href=\"https://www.vpnnice.com/best-vpn-china/\">2019年中国最佳翻墙VPN</a></p>\n</li>\n<li>\n<p><a href=\"https://www.vpnnice.com/free-vpn/\">2019年免费翻墙VPN推荐</a></p>\n</li>\n<li>\n<p><a href=\"https://www.vpnnice.com/best-vpn-iphone/\"> IOS vpn推荐</a></p>\n</li>\n</ul>\n</div>","title":"中国VPN安全翻墙攻略，最好用的付费VPN。","last_reply_at":"2019-09-24T09:25:20.547Z","good":false,"top":false,"reply_count":0,"visit_count":592,"create_at":"2019-09-24T09:25:20.547Z","author":{"loginname":"vpnnice","avatar_url":"https://avatars2.githubusercontent.com/u/55436549?v=4&s=120"}},{"id":"5d882bba95464514f7ed91cd","author_id":"59266cb1d371b6372a8afd7c","tab":"ask","content":"<div class=\"markdown-text\"><p>os模块获取到的是逻辑处理器数目，对于有超线程的CPU，物理内核数只有逻辑处理器数目的一半\n<img src=\"//static.cnodejs.org/Fq7KFx0EL_dOAajPitsn1XY9VDAM\" alt=\"Snipaste_2019-09-23_10-19-06.png\"></p>\n</div>","title":"如何在node.js里获取CPU的物理内核数目 ?","last_reply_at":"2019-09-24T07:32:45.885Z","good":false,"top":false,"reply_count":6,"visit_count":581,"create_at":"2019-09-23T02:19:38.919Z","author":{"loginname":"Kinghts","avatar_url":"https://avatars0.githubusercontent.com/u/7201507?v=4&s=120"}},{"id":"58aeee58e418a986315f3882","author_id":"538ebff9c3ee0b58208376c7","tab":"share","content":"<div class=\"markdown-text\"><p>大家一起去申诉：\n<a href=\"http://www.chinatcc.gov.cn\">http://www.chinatcc.gov.cn</a></p>\n</div>","title":"听说GitHub被封了？这可咋办呀？","last_reply_at":"2019-09-24T05:56:37.215Z","good":false,"top":false,"reply_count":20,"visit_count":5039,"create_at":"2017-02-23T14:14:48.715Z","author":{"loginname":"zhanzhenzhen","avatar_url":"https://avatars3.githubusercontent.com/u/731796?v=4&s=120"}},{"id":"53cb4bb2c9507b40443238cb","author_id":"50d42706637ffa4155f726ad","tab":"share","content":"<div class=\"markdown-text\"><p>编写这个服务的初衷是给我女朋友写论文查资料用的。写完后觉得可以开源出来，集结大家的力量继续完善，并且每个人都可以部署到自己的vps上给自己或朋友用，然后就可以有无数的免翻墙使用的谷歌服务造福大众了。</p>\n<p>这是我自己搭建的服务： <a href=\"http://gso.mlongbo.com\">http://gso.mlongbo.com</a>    或  <a href=\"http://gusou.in\">http://gusou.in</a> （不要大量扩散哦，偷偷地告诉身边的朋友就好了~）</p>\n<p>源代码： <a href=\"https://github.com/lenbo-ma/gso.git\">https://github.com/lenbo-ma/gso.git</a></p>\n<p>本人为前端菜鸟，对该项目感兴趣的大神可以将css重构下～</p>\n<p>以后可以考虑增加在线代理功能，代理搜索结果中一些被qiang的技术网站。</p>\n<p>有兴趣的同学也可以 <a href=\"http://jq.qq.com/?_wv=1027&amp;k=PaD5gT\">加入QQ群: 338257594</a> 一起交流~</p>\n</div>","title":"gso，使用nodejs编写的谷歌搜索代理服务(免翻墙)，可以自由部署在自己的国外vps上","last_reply_at":"2019-09-24T05:54:18.212Z","good":true,"top":false,"reply_count":23,"visit_count":7680,"create_at":"2014-07-20T04:55:14.974Z","author":{"loginname":"lenbo","avatar_url":"https://avatars1.githubusercontent.com/u/2613341?v=3&s=120"}},{"id":"583191e267db500b79c100ed","author_id":"582468cc8e0f8bb038f38b6e","tab":"share","content":"<div class=\"markdown-text\"><p><strong>前言</strong></p>\n<p><strong>此教主要程针对已经能够科学上网,但不想继续花费高额vpn费用的用户.</strong>\n<strong>但是</strong>如果还不会科学上网,也没有关系.请购买<strong>体验套餐</strong>.然后访问gfw.press官网,注册账号.实现<strong>永久免费服务</strong>.</p>\n<blockquote>\n<ul>\n<li>GFW.Press将方法配合SwitchOmega / SocksCap64两款软件实现<strong>一键fq</strong>.*</li>\n</ul>\n</blockquote>\n<hr>\n<p>=======================================完美的分割线======================================</p>\n<h2><strong>1. GFW.Press</strong>\n在这里首先感谢赵国劣绅 石斑鱼大爷  <a href=\"https://github.com/chinashiyu\">github源码</a>\n<strong>教程开始</strong>\n<em>首先要登录官网注册账号,能翻樯的直接登录gfw.press,不能翻樯的先购买体验服务</em>\n** <a href=\"https://my.shadowsocksr.com/cart.php?gid=7\">体验套餐购买地址</a>**\n** <a href=\"https://my.shadowsocksr.com/knowledgebase.php?action=displayarticle&amp;id=26\">购买完毕使用教程</a>**</h2>\n<p>现在已经大家都能够翻樯了.接下来就要使用免费服务了.</p>\n<ul>\n<li>\n<p>1.登录gfw.press官网**(这里需要翻樯)**</p>\n</li>\n<li>\n<p>2.点击注册</p>\n</li>\n<li>\n<p>3.注册成功后点击登录,你将会看到节点信息\n<img src=\"//static.cnodejs.org/FjRR4JHK1lc6SzxNtnAc8HmumyOH\" alt=\"Press用户界面.PNG\"></p>\n</li>\n<li>\n<p>4.下载gfw.press软件. 由于下载经常会断开.我已经下好了.      <a href=\"http://pan.baidu.com/s/1kVlW7np\">百度云链接</a>密码:hffg</p>\n</li>\n<li>\n<p>5.安装完毕后双击打开,并安装gfw.press官网中提供的账号填入节点,端口以及密码.</p>\n</li>\n<li>\n<p>6.打开谷歌浏览器,搜索chrome网上应用店,打开并搜索插件switchomega,安装插件   <strong>(这里需要翻樯)</strong>\n<img src=\"//static.cnodejs.org/FjJmrA7AVIocymjZN_-SN2RgrPih\" alt=\"chrome网上应用店下载switchomega插件.png\"></p>\n</li>\n<li>\n<p>7.下载完毕后,你的谷歌浏览器右上角将多出一个小图标.单击选项按钮进入管理界面.\n<img src=\"//static.cnodejs.org/FvkjspPx9UswCmRl07ZUkxnqSJ8q\" alt=\"switchomega配置说明-1.png\"></p>\n</li>\n<li>\n<p>8.进入管理界面后,进行如下配置\n\t(1)新建情景模式\n<img src=\"//static.cnodejs.org/FkRw9vxJhAECricmXA4xbjG318x6\" alt=\"switchomega配置说明-2.png\">\n\t(2)填入路由信息\n<img src=\"//static.cnodejs.org/FqqxP52d_OWXfxc2BZMuHViObcsm\" alt=\"switchomega配置说明-3.png\"></p>\n</li>\n<li>\n<p>9.填完以后一定记得点击  <strong>应用选项</strong>  保存刚才的配置.然后关闭标签页即可.</p>\n</li>\n<li>\n<p>10.此时单击你右上角的switchomega插件将会多出一个GFW.press选项.\n<img src=\"//static.cnodejs.org/Fn1Px1sehKJoPP35CubVqFTTimxh\" alt=\"untitled1.png\">\n11.点击切换到GFW.Press模式下,恭喜你.可以永久免费翻樯了.\n12.如果你不确定自己有没有成功,那么登录ipip.net就能看到自己的ip地址了.\n<img src=\"//static.cnodejs.org/FtjJX7vhuCy1wx-KHyRddqsUOWRP\" alt=\"switchomega配置说明-5.png\"></p>\n</li>\n</ul>\n</div>","title":"GFW.Press永久翻樯(免费)","last_reply_at":"2019-09-24T05:52:07.116Z","good":false,"top":false,"reply_count":25,"visit_count":109798,"create_at":"2016-11-20T12:06:58.395Z","author":{"loginname":"yuxiaochi12345","avatar_url":"https://avatars.githubusercontent.com/u/18710967?v=3&s=120"}},{"id":"5d884dd895464514f7ed92b7","author_id":"5b473d7c13ca2fe569fb9346","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fnda8bfg5VxKKTyyt0uMhODosaRe\" alt=\"https___www.lifeofpix.com_wp-content_uploads_2018_06_DSC_2694.jpg\"></p>\n<h2>前言</h2>\n<p>为了让开发者更加便利，初始化项目的 CLI 工具已经成为各个前端框架、或者解决方案的标配。一行命令就可以初始化一个项目，并且还能选择一些配置项来达到自定制的目的，这样的确提高了开发者的效率，提升了使用体验。但是，随着业务中项目的增多，我们会发现这些并不能足够满足需求。</p>\n<h2>现状</h2>\n<p>比如，Vue CLI3 提供了诸多配置选项，还能支持视图，Create-React-App 将配置项隐藏，还能给人快速上手、专注业务的体验。但为什么我们会慢慢地觉得这类脚手架无法满足需求？因为这一类 CLI 的作用就是用来初始化一个全新的项目，但除了初始化全新项目之外，还有很多情况是需要复用以前的<strong>项目模版</strong>的，这些模板可能安装了一些项目中必须要用到的包、或者包含了一些必要的业务模块，这些是上述 CLI 无法满足的。</p>\n<p>我们最常用的复用项目模版的方式就是复制，复制无疑是低效的，那既然如此，我们就可以抽出一套代码专门作为具有针对性的项目模板，抽出来之后，通过一行命令就能直接安装搞定，是不是会更轻松。</p>\n<p>还有一点，社区有很多开发者写好的模版就放在 Github 上，我们想用的时候会去 Fork 或者 Clone 到本地来做修改。比如备受好评的 <a href=\"https://github.com/PanJiaChen/vue-element-admin\">vue-element-admin</a>，模板开发者本身是没有提供类似 CLI 来让使用者更便捷的用上这个模板的。那如果有这样一个工具可以一行命令便能初始化，岂不是更好。</p>\n<h2>进入正题</h2>\n<p>说了那么多，无非是为了说明 <strong>Mieo</strong> 这个 CLI 的出发点以及想要达到的效果。同时更多的是想传达一种思想——在遇到特定场景时，可以想办法去改善现有的状况。我并没有调研过是否有其他类似 CLI 可以做这样一个事情，自己的出发点其实就是为了一个场景，我发现每次自己去初始化一个 React 项目的时候，都需要按照 antd 配置一遍 antd、按需加载、覆盖默认配置、Redux 等等一系列的过程，我很累…很明显其他人也会遇到这种情况，所以我建议有需求的都可以自己造个轮子，实现很简单，但会方便不少，而且想尝试一下用 Node 写命令行程序的朋友也能多一点有意义的实践。</p>\n<p>废话不多说，我自己初步实现了这样一个 CLI，目前不完善，但是能用。接下来先简单说一下使用方式，然后讲一讲实现思路、技术细节以及之后能做的事情。Mieo 的项目地址为 <a href=\"https://github.com/seymoe/mieo\">https://github.com/seymoe/mieo</a>，有兴趣可以去看看，如果有自己实现的想法可以 Fork 或者直接看，代码量不多，但是我基本做了注释，适合新手向，顺便求 🌟 ～</p>\n<h3>使用方式</h3>\n<ul>\n<li>安装 Mieo</li>\n</ul>\n<pre class=\"prettyprint\"><code>npm install -g mieo\n</code></pre><ul>\n<li>查看帮助与版本</li>\n</ul>\n<pre class=\"prettyprint\"><code>mieo -h\nmieo -V\n</code></pre><ul>\n<li>选择模版，初始化项目，目前模版还只有两个，mieotpl-egg-mongoo-ts和mieotpl-react-antd-ts</li>\n</ul>\n<pre class=\"prettyprint\"><code>mieo init your_project_name\n</code></pre><h3>实现思路</h3>\n<p>思路很简单，我们要做的就是一个命令行程序，能够通过命令执行一系列操作。命令行执行  <code>init</code> 指令，会去查询现有的模板列表，选择模板开始拉取模版到本地，然后自动进行依赖包的安装，最后提示安装成功，可以去按照模板的相应命令进行开发工作了。</p>\n<h3>技术细节</h3>\n<h4>可执行文件</h4>\n<p>为了我们的 <code>mieo</code> 命令能够在命令行执行，那我们需要一个可执行文件，Unix 系统上使用 <code>#!/usr/bin/env node</code> 来进行标示，Windows 可能会有兼容性问题，未测试，有兴趣可以在 Power Shell 上尝试。我们在项目中创建了一个 <code>mieo</code> 文件，然后在 <code>package.json</code> 中指定 <code>bin</code> 选项。</p>\n<pre class=\"prettyprint\"><code>&quot;bin&quot;: {\n    &quot;mieo&quot;: &quot;.&#x2F;bin&#x2F;mieo&quot;\n }\n</code></pre><p>这样我们就能本地测试了，在项目中执行 <code>npm link</code> ，将会创建软连接指向我们这个项目，所以我们可以在其他目录下也能执行 <code>mieo</code> 命令了。</p>\n<h4>接收命令</h4>\n<p>项目中采用了 <code>commander</code> 这个库，能方便的生成版本和帮助信息，创建 <code>init</code> 命令的方式也很简单。</p>\n<pre class=\"prettyprint\"><code>    initProgram() {\n        this.program = new commander.Command()\n        &#x2F;&#x2F; CLI 的版本信息\n        this.program\n          .version(pkg.version)\n        &#x2F;&#x2F; init 命令\n        this.program\n          .command(&#x27;init &lt;dir&gt;&#x27;)\n          .description(&#x27;Init a project by choosing template.&#x27;)\n          .action((dir) =&gt; initScript(this, dir))\n        &#x2F;&#x2F; 提供系统参数来给 commander 解析\n        this.program.parse(process.argv)\n    }\n</code></pre><h4>config.json</h4>\n<p>这个文件记录了所以的模板列表，以供使用者选择。</p>\n<pre class=\"prettyprint\"><code>{\n  &quot;list&quot;: [\n    {\n      &quot;name&quot;: &quot;mieotpl-egg-mongoo-ts&quot;,\n      &quot;remote&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;seymoe&#x2F;mieotpl-egg-mongoo-ts.git&quot;\n    }\n  ]\n}\n</code></pre><h4>init 命令</h4>\n<p>这个命令接收一个参数，这个参数为文件夹名称。用到了 <code>inquirer</code> 这个库来做用户选择的交互式处理，通过获取 <code>config.json</code> 的数据，供使用者选择，选择之后去看本地的缓存目录是否存在这个模板的源文件，如果有，则比对模板的版本，线上发布的版本比本地的新，则直接进行更新(优化点：给使用者选择的余地)，如果版本没有变化则直接拷贝缓存中的文件。然后进入传入的文件夹名称，执行 <code>npm i</code> 的操作（优化点：支持 yarn），安装完成提示。</p>\n<p>这里有一点需要注意，因为模版比对方法是 <code>npm view [template name] version --json</code>，所以为了避免比对有误差，需要保证模版的名字在 npm 库中是唯一的，比如我的就是以 <code>mieotpl-</code> 开头。</p>\n<p>具体见 <a href=\"https://github.com/seymoe/mieo/blob/master/scripts/init.js\">源码</a></p>\n<h4>关于模板</h4>\n<p>目前本人是计划完善两个模版，后面有需求再添加：</p>\n<ol>\n<li><a href=\"https://github.com/seymoe/mieotpl-egg-mongoo-ts\">mieotpl-egg-mongoo-ts</a> eggjs、mongoose的ts模板</li>\n<li><a href=\"https://github.com/seymoe/mieotpl-react-antd-ts\">mieotpl-react-antd-ts</a> 配好react、antd的ts版本模板（待完成）</li>\n</ol>\n<h3>总结</h3>\n<p>在以上的实践里，我们也能发现一些需要优化的点：</p>\n<ul>\n<li>在模板版本比对出现差异时，应该把选择权交给用户</li>\n<li>安装依赖时，应该给用户选择用 npm 还是 yarn 的余地</li>\n<li>执行命令时，没有任何输出，应该优化</li>\n<li>加载动画</li>\n<li>流程优化，比如选择模版之后显示更多的模版信息</li>\n<li>初始化时的文件夹是否已经存在的判断</li>\n</ul>\n<p>待优化的点可以解决，但目前对于自己使用已经满足了需求，重点是模版的准备。总体来说，Mieo 只是思路的核心实践，如果真的需要成为一个通用性 CLI，要做的还有很多，相信每个人在实践过程中都会有自己的想法，强烈建议自己尝试一把。</p>\n<p>本文首发于 <a href=\"https://www.e7fe.com/post/5d872fc30d44356e1c6c1f70\">https://www.e7fe.com/post/5d872fc30d44356e1c6c1f70</a> ，欢迎批评指正。</p>\n</div>","title":"🐱 Mieo，前端“通用”脚手架养成指南","last_reply_at":"2019-09-24T05:50:11.019Z","good":false,"top":false,"reply_count":3,"visit_count":755,"create_at":"2019-09-23T04:45:12.073Z","author":{"loginname":"ximolang","avatar_url":"https://avatars3.githubusercontent.com/u/25032899?v=4&s=120"}},{"id":"593d631a325c502917ef0881","author_id":"541878e05f67e2b8570e1c65","tab":"ask","content":"<div class=\"markdown-text\"><p>最近有墙外网站爬虫需求，做了个demo发现node的http/request等模块一旦请求墙外站点，就会返回“connect refused”之类的提示。要么就是timeout。换回墙内站点就各种没问题。</p>\n<p>我翻墙是用shadowsocks，不知道是不是这个只能解决浏览器翻墙问题。</p>\n<p>有没有大神可以指点一下接下来应该怎么做，有点迷茫</p>\n</div>","title":"翻墙后无法node请求墙外站点","last_reply_at":"2019-09-24T05:50:00.601Z","good":false,"top":false,"reply_count":7,"visit_count":2535,"create_at":"2017-06-11T15:34:50.921Z","author":{"loginname":"backlost","avatar_url":"https://avatars0.githubusercontent.com/u/4522159?v=4&s=120"}},{"id":"554b34afb68166372e6000fb","author_id":"535cbb096b02f25e580123e9","tab":"ask","content":"<div class=\"markdown-text\"><p>本来不想买vpn\n最近平常上的搜索都给封了\n所以，便宜的vpn也认了\n当然，还是免费的最好啦\n对这种闭关锁国的寡妇网表示鄙视\n各位大大，给点推荐吧</p>\n</div>","title":"求上谷歌方法","last_reply_at":"2019-09-24T05:47:13.728Z","good":false,"top":false,"reply_count":49,"visit_count":9680,"create_at":"2015-05-07T09:47:27.812Z","author":{"loginname":"CarlosRen","avatar_url":"https://avatars0.githubusercontent.com/u/6012322?v=4&s=120"}},{"id":"56cef313a1658d484d7a3676","author_id":"563f17d0b0cedafd38970462","tab":"share","content":"<div class=\"markdown-text\"><p>在中国有很多特色的东西，防火长城阻碍了很多人浏览外界的机会，也成就了很多人，比如：一度很火的红杏。但是，这些服务，都不长久，慢慢都被和谐了。所以，掌握几个免费的Vpn是必要的。这里，介绍我常用的几个，希望对大家有帮助：</p>\n<h2>（1）Lantern</h2>\n<p>这是一个免费、简单、开源，基于P2P网络，去中心化的应用程序。它的目标就是帮助你随时随地快速、可靠、安全地访问互联网。支持移动android等。</p>\n<p>源码在这里：<a href=\"https://github.com/getlantern/lantern\">https://github.com/getlantern/lantern</a></p>\n<p>官方网站https://getlantern.org/</p>\n<p>直接下载安装即可。</p>\n<h2>（2）Bitnet</h2>\n<p>中文名叫微币，原来叫vpncoin，是一种加密货币，当然也是去中心化的应用了。一开始也是以提供科学上网vpn起家的，你可以在线挣取其他节点的上网时间。</p>\n<p>官网：<a href=\"http://www.bitnet.cc/\">http://www.bitnet.cc/</a></p>\n<h2>（3）自己快速搭建</h2>\n<p>亚马逊，提供了一个1年期的免费主机，配置也足够用了。在 ec2虚拟机上，安装一个Ubuntu服务器。使用下面的一条命令，打造一个ssh代理：</p>\n<pre class=\"prettyprint\"><code>sudo ssh -v -i ~&#x2F;.ssh&#x2F;Your.pem ubuntu@[EC2公网IP] -D 8888 -C\n</code></pre><p>Your.pem是您的密钥，aws必须的。EC2公网IP，aws会自动分配。8888为代理端口号，代理服务器是<code>localhost</code>。然后，在浏览器的代理设置里，就可以直接用了。</p>\n<p>喜欢加密货币的小盆友，可以联系我，微信：kubying</p>\n</div>","title":"使用VPN翻Qiang，还用花钱吗？告诉你三种简单快捷的省钱方法。。。","last_reply_at":"2019-09-24T05:41:58.482Z","good":false,"top":false,"reply_count":5,"visit_count":23437,"create_at":"2016-02-25T12:26:59.486Z","author":{"loginname":"imfly","avatar_url":"https://avatars2.githubusercontent.com/u/12215508?v=4&s=120"}},{"id":"5514b132e26684ed7ff21bf2","author_id":"53fdd8502243147e7857b2bb","tab":"ask","content":"<div class=\"markdown-text\"><p>发现一堆网站上不了\n你们都用什么 VPN? 推荐下\n以前到 V2EX 查，发现 V2EX 也上不了\n免费的付费的都行</p>\n</div>","title":"你用什么 VPN?","last_reply_at":"2019-09-24T05:40:45.872Z","good":false,"top":false,"reply_count":37,"visit_count":23793,"create_at":"2015-03-27T01:24:02.838Z","author":{"loginname":"russj","avatar_url":"https://avatars2.githubusercontent.com/u/2281763?v=4&s=120"}},{"id":"5d75ef73d50f572345912d7a","author_id":"5bfffab8d6104a4f803a2fbb","tab":"share","content":"<div class=\"markdown-text\"><p>这个论坛程序是前一段时间学习koa2的实践作品，技术栈是“koa2+react+mongodb”，已部署到：<a href=\"http://65.49.193.60:3001\">http://65.49.193.60:3001</a></p>\n<p>已经初步实现的功能：</p>\n<ul>\n<li>发帖/删除/更改/置顶/点赞/匿名</li>\n<li>接龙/投票</li>\n<li>登录注册/修改密码/通过邮件重置密码/GitHub登录</li>\n<li>用户角色（admin/bm/user三级）及用户管理</li>\n<li>上传头像及修改</li>\n<li>中英文界面切换</li>\n<li>markdown编辑</li>\n<li>板块可配置</li>\n<li>保存退出时状态</li>\n</ul>\n<p>尚未实现功能：</p>\n<ul>\n<li>搜索</li>\n<li>私信</li>\n<li>@</li>\n<li>图片或文件上传</li>\n<li>后台管理</li>\n</ul>\n<p>client： <a href=\"https://github.com/maxyou/purebbs\">https://github.com/maxyou/purebbs</a>\nserver：<a href=\"https://github.com/maxyou/purebbs-server\">https://github.com/maxyou/purebbs-server</a></p>\n<p>出于学习的目的，尽量不使用第三方UI库，所以界面比较原始。头次写论坛程序，不足之处太多，欢迎朋友们提出批评建议。</p>\n</div>","title":"学习nodejs，写了一个初级简版的论坛程序，请批判建议","last_reply_at":"2019-09-24T04:39:23.364Z","good":false,"top":false,"reply_count":10,"visit_count":2344,"create_at":"2019-09-09T06:21:39.389Z","author":{"loginname":"maxyou","avatar_url":"https://avatars1.githubusercontent.com/u/1485628?v=4&s=120"}},{"id":"5d898df74f109e79ef5ff19d","author_id":"5d7082fca7474a231a5890c8","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FgivX4oZM037gR3cmlTr1767cfIQ\" alt=\"捕获.PNG\"></p>\n</div>","title":"npm loader插件中的done方法  三个参数是什么意思","last_reply_at":"2019-09-24T03:31:03.599Z","good":false,"top":false,"reply_count":0,"visit_count":235,"create_at":"2019-09-24T03:31:03.599Z","author":{"loginname":"AlanWalkerQAQ","avatar_url":"https://avatars1.githubusercontent.com/u/33818516?v=4&s=120"}},{"id":"5befe1b1be1b120abac5a592","author_id":"5b5a7729b71aedfe4c12652b","tab":"share","content":"<div class=\"markdown-text\"><p>6套经典node.js+vue项目实战视频教程，大家看看下面具体教程，有需要的可以学习一下哦</p>\n<p><img src=\"//static.cnodejs.org/FisDxxcRtOtl7qWtIwYMfYzDTr2G\" alt=\"11111.jpg\"></p>\n<p><strong>教程如下：</strong>\n[node]7天搞定NodeJS微信公众号开发\n[vue]vue2.0+node.js+MongoDB全栈打造商城（新录制）\nVue+Node+MongoDB小程序公众号全栈项目开发实战\nnode.js从入门到实战教育项目\nVue+Node+MongoDB小程序公众号全栈项目开发实战\n【实战】Node.js + Web Socket 打造即时通讯聊天程序</p>\n<p>下载地址：<a href=\"http://www.sucaihuo.com/video/378.html\">http://www.sucaihuo.com/video/378.html</a></p>\n</div>","title":"6套经典node.js+vue项目实战视频教程","last_reply_at":"2019-09-24T02:16:29.848Z","good":false,"top":false,"reply_count":38,"visit_count":12038,"create_at":"2018-11-17T09:38:57.164Z","author":{"loginname":"codeofking","avatar_url":"https://avatars2.githubusercontent.com/u/41748064?v=4&s=120"}},{"id":"5d886b2395464514f7ed93e5","author_id":"5c81f15090c14711cc8cb87e","tab":"share","content":"<div class=\"markdown-text\"><p>目前 nestjs用的人多还是egg.js用的人多？ 有用nest开发的童鞋吗？</p>\n</div>","title":"目前 nestjs用的人多还是egg.js用的人多？ 有用nest开发的童鞋吗","last_reply_at":"2019-09-24T00:40:15.123Z","good":false,"top":false,"reply_count":5,"visit_count":622,"create_at":"2019-09-23T06:50:11.095Z","author":{"loginname":"phonegap100","avatar_url":"https://avatars1.githubusercontent.com/u/5773766?v=4&s=120"}},{"id":"5d6de312a7474a231a5886bd","author_id":"5c18354b7ec239239ff57c7f","tab":"share","content":"<div class=\"markdown-text\"><p>去年和朋友一起翻译的《架构师修炼之道》最近出版了。水平有限，请大家多多指正。荣誉是大家的，有错误都算我的！</p>\n<p>这本书是写给想当架构师的童鞋看的，全书分两个部分，第一部分主要讲程序猿要掌握哪些思维方式和工作方式才能成为架构师，以及架构设计的案例。第二部分归纳若干带领团队设计架构的方法和技巧。国外读者对这本书评价很高，原书读起来也很流畅，但愿我们翻译没拖后腿。</p>\n<p>闲话少说，这里有<strong>38页试读</strong>：<a href=\"https://pan.baidu.com/s/1pk50WEv9XqjHkLtH7iXxgg\">https://pan.baidu.com/s/1pk50WEv9XqjHkLtH7iXxgg</a></p>\n<p>希望这本书对大家升职加薪脱单有帮助:)</p>\n<p><strong>天猫有售</strong>：<a href=\"https://detail.tmall.com/item.htm?spm=a230r.1.14.15.1cea1774yUneie&amp;id=601144871555\">https://detail.tmall.com/item.htm?spm=a230r.1.14.15.1cea1774yUneie&amp;id=601144871555</a></p>\n<p><img src=\"//static.cnodejs.org/Fi-NjeCWw2xxioeMNBpnWVzhyDYO\" alt=\"QQ图片20190830144122.jpg\"></p>\n</div>","title":"新书《架构师修炼之道》试读","last_reply_at":"2019-09-23T15:25:12.619Z","good":false,"top":false,"reply_count":8,"visit_count":3382,"create_at":"2019-09-03T03:50:42.832Z","author":{"loginname":"sean-xu","avatar_url":"https://avatars0.githubusercontent.com/u/430849?v=4&s=120"}}]}